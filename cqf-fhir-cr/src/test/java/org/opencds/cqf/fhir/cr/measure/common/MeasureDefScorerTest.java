package org.opencds.cqf.fhir.cr.measure.common;

import static org.junit.jupiter.api.Assertions.*;

import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import org.junit.jupiter.api.Test;
import org.opencds.cqf.fhir.cr.measure.MeasureStratifierType;

/**
 * Comprehensive unit tests for version-agnostic MeasureDefScorer.
 *
 * Tests the Def-first iteration pattern AND mutation-based design where
 * scores are set directly on Def objects using setScore() methods.
 *
 * All tests use constructors to create Def objects (NO MOCKS).
 *
 * Generated by Claude Sonnet 4.5 on 2025-12-03
 */
class MeasureDefScorerTest {

    @Test
    void testScoreGroup_SetsScoreOnGroupDef() {
        // Setup: Simple proportion measure with 3/4 subjects meeting criteria
        CodeDef encounterBasis = createPopulationBasisCode("Encounter");
        PopulationDef numeratorPop = createPopulationDef(
                "num-1", MeasurePopulationType.NUMERATOR, Set.of("patient1", "patient2", "patient3"), encounterBasis);
        PopulationDef denominatorPop = createPopulationDef(
                "den-1",
                MeasurePopulationType.DENOMINATOR,
                Set.of("patient1", "patient2", "patient3", "patient4"),
                encounterBasis);

        GroupDef groupDef = new GroupDef(
                "group-1",
                createTextOnlyConcept("Test Group"),
                List.of(), // No stratifiers
                List.of(numeratorPop, denominatorPop),
                MeasureScoring.PROPORTION,
                false,
                createImprovementNotationCode("increase"),
                encounterBasis);

        // Score is null before scoring
        assertNull(groupDef.getScore());

        MeasureDefScorer scorer = new MeasureDefScorer();
        scorer.scoreGroup("http://example.com/Measure/test", groupDef);

        // VERIFY: Score is set on GroupDef via mutation
        assertEquals(0.75, groupDef.getScore(), 0.001);
        // VERIFY: getMeasureScore returns score as-is for increase notation
        assertEquals(0.75, groupDef.getMeasureScore(), 0.001);
    }

    @Test
    void testScoreGroup_ProportionWithExclusions() {
        // Setup: Proportion measure with exclusions and exceptions
        // Formula: (n - nx) / (d - dx - de)
        // (10 - 2) / (20 - 3 - 1) = 8 / 16 = 0.5
        CodeDef stringBasis = createPopulationBasisCode("String");
        PopulationDef numeratorPop = createPopulationDef(
                "num-1",
                MeasurePopulationType.NUMERATOR,
                Set.of("p1", "p2", "p3", "p4", "p5", "p6", "p7", "p8", "p9", "p10"),
                stringBasis);
        PopulationDef denominatorPop = createPopulationDef(
                "den-1",
                MeasurePopulationType.DENOMINATOR,
                Set.of(
                        "p1", "p2", "p3", "p4", "p5", "p6", "p7", "p8", "p9", "p10", "p11", "p12", "p13", "p14", "p15",
                        "p16", "p17", "p18", "p19", "p20"),
                stringBasis);
        PopulationDef denExclusionPop = createPopulationDef(
                "dex-1", MeasurePopulationType.DENOMINATOREXCLUSION, Set.of("p11", "p12", "p13"), stringBasis);
        PopulationDef denExceptionPop =
                createPopulationDef("dexc-1", MeasurePopulationType.DENOMINATOREXCEPTION, Set.of("p14"), stringBasis);
        PopulationDef numExclusionPop =
                createPopulationDef("nex-1", MeasurePopulationType.NUMERATOREXCLUSION, Set.of("p1", "p2"), stringBasis);

        GroupDef groupDef = new GroupDef(
                "group-1",
                createTextOnlyConcept("Test Group"),
                List.of(),
                List.of(numeratorPop, denominatorPop, denExclusionPop, denExceptionPop, numExclusionPop),
                MeasureScoring.PROPORTION,
                false,
                createImprovementNotationCode("increase"),
                stringBasis);

        MeasureDefScorer scorer = new MeasureDefScorer();
        scorer.scoreGroup("http://example.com/Measure/test", groupDef);

        // VERIFY: Score is set correctly
        assertEquals(0.5, groupDef.getScore(), 0.001);
    }

    @Test
    void testScoreGroup_ZeroDenominator_SetsNullScore() {
        // Setup: All subjects excluded from denominator
        CodeDef dateBasis = createPopulationBasisCode("date");
        PopulationDef numeratorPop = createPopulationDef(
                "num-1", MeasurePopulationType.NUMERATOR, Set.of("p1", "p2", "p3", "p4", "p5"), dateBasis);
        PopulationDef denominatorPop = createPopulationDef(
                "den-1",
                MeasurePopulationType.DENOMINATOR,
                Set.of("p1", "p2", "p3", "p4", "p5", "p6", "p7", "p8", "p9", "p10"),
                dateBasis);
        PopulationDef denExclusionPop = createPopulationDef(
                "dex-1",
                MeasurePopulationType.DENOMINATOREXCLUSION,
                Set.of("p1", "p2", "p3", "p4", "p5", "p6", "p7", "p8", "p9", "p10"),
                dateBasis); // All excluded

        GroupDef groupDef = new GroupDef(
                "group-1",
                createTextOnlyConcept("Test Group"),
                List.of(),
                List.of(numeratorPop, denominatorPop, denExclusionPop),
                MeasureScoring.PROPORTION,
                false,
                createImprovementNotationCode("increase"),
                dateBasis);

        MeasureDefScorer scorer = new MeasureDefScorer();
        scorer.scoreGroup("http://example.com/Measure/test", groupDef);

        // VERIFY: Null score set for zero denominator
        assertNull(groupDef.getScore());
    }

    @Test
    void testScoreStratifier_SetsScoresOnStratumDefs() {
        // Setup: Group with stratifier containing two strata
        // Male stratum: 3/5 = 0.6
        // Female stratum: 5/5 = 1.0

        CodeDef booleanBasisCode = createPopulationBasisCode("boolean");
        PopulationDef numeratorPop = createPopulationDef(
                "num-1",
                MeasurePopulationType.NUMERATOR,
                Set.of("male1", "male2", "male3", "female1", "female2", "female3", "female4", "female5"),
                booleanBasisCode);
        PopulationDef denominatorPop = createPopulationDef(
                "den-1",
                MeasurePopulationType.DENOMINATOR,
                Set.of(
                        "male1", "male2", "male3", "male4", "male5", "female1", "female2", "female3", "female4",
                        "female5"),
                booleanBasisCode);

        // Create stratum populations for Male stratum

        StratumPopulationDef maleNumPop = new StratumPopulationDef(
                numeratorPop,
                Set.of("male1", "male2", "male3"),
                Set.of(),
                List.of(),
                MeasureStratifierType.VALUE,
                booleanBasisCode);
        StratumPopulationDef maleDenPop = new StratumPopulationDef(
                denominatorPop,
                Set.of("male1", "male2", "male3", "male4", "male5"),
                Set.of(),
                List.of(),
                MeasureStratifierType.VALUE,
                booleanBasisCode);

        StratifierComponentDef genderComponent =
                new StratifierComponentDef("gender-component", createTextOnlyConcept("Gender"), "Gender");
        StratumDef maleStratum = new StratumDef(
                List.of(maleNumPop, maleDenPop),
                Set.of(new StratumValueDef(new StratumValueWrapper("male"), genderComponent)),
                Set.of("male1", "male2", "male3", "male4", "male5"),
                null);

        // Create stratum populations for Female stratum
        StratumPopulationDef femaleNumPop = new StratumPopulationDef(
                numeratorPop,
                Set.of("female1", "female2", "female3", "female4", "female5"),
                Set.of(),
                List.of(),
                MeasureStratifierType.VALUE,
                booleanBasisCode);
        StratumPopulationDef femaleDenPop = new StratumPopulationDef(
                denominatorPop,
                Set.of("female1", "female2", "female3", "female4", "female5"),
                Set.of(),
                List.of(),
                MeasureStratifierType.VALUE,
                booleanBasisCode);

        StratumDef femaleStratum = new StratumDef(
                List.of(femaleNumPop, femaleDenPop),
                Set.of(new StratumValueDef(new StratumValueWrapper("female"), genderComponent)),
                Set.of("female1", "female2", "female3", "female4", "female5"),
                null);

        StratifierDef stratifierDef = new StratifierDef(
                "gender-stratifier", createTextOnlyConcept("Gender Stratifier"), "Gender", MeasureStratifierType.VALUE);
        stratifierDef.addAllStratum(List.of(maleStratum, femaleStratum));

        GroupDef groupDef = new GroupDef(
                "group-1",
                createTextOnlyConcept("Test Group"),
                List.of(stratifierDef),
                List.of(numeratorPop, denominatorPop),
                MeasureScoring.PROPORTION,
                false,
                createImprovementNotationCode("increase"),
                booleanBasisCode);

        // Scores are null before scoring
        assertNull(maleStratum.getScore());
        assertNull(femaleStratum.getScore());

        // Execute
        MeasureDefScorer scorer = new MeasureDefScorer();
        scorer.scoreGroup("http://example.com/Measure/test", groupDef);

        // VERIFY: Scores are set on each StratumDef via mutation
        assertEquals(0.6, maleStratum.getScore(), 0.001); // Male: 3/5
        assertEquals(1.0, femaleStratum.getScore(), 0.001); // Female: 5/5
    }

    @Test
    void testScoreGroup_RatioMeasure() {
        // Setup: Ratio measure with 6/12 = 0.5
        CodeDef stringBasis = createPopulationBasisCode("String");
        PopulationDef numeratorPop = createPopulationDef(
                "num-1", MeasurePopulationType.NUMERATOR, Set.of("p1", "p2", "p3", "p4", "p5", "p6"), stringBasis);
        PopulationDef denominatorPop = createPopulationDef(
                "den-1",
                MeasurePopulationType.DENOMINATOR,
                Set.of("p1", "p2", "p3", "p4", "p5", "p6", "p7", "p8", "p9", "p10", "p11", "p12"),
                stringBasis);

        GroupDef groupDef = new GroupDef(
                "group-1",
                createTextOnlyConcept("Test Group"),
                List.of(),
                List.of(numeratorPop, denominatorPop),
                MeasureScoring.RATIO,
                false,
                createImprovementNotationCode("increase"),
                stringBasis);

        assertNull(groupDef.getScore());

        MeasureDefScorer scorer = new MeasureDefScorer();
        scorer.scoreGroup("http://example.com/Measure/test", groupDef);

        assertEquals(0.5, groupDef.getScore(), 0.001);
    }

    @Test
    void testScoreGroup_ContinuousVariable_SumAggregation() {
        // Setup: Continuous variable measure with SUM aggregation
        // Subject observations: 10.0, 20.0, 30.0 = 60.0 total
        CodeDef dateBasis = createPopulationBasisCode("date");
        PopulationDef initialPopulation = createPopulationDef(
                "ip-1", MeasurePopulationType.INITIALPOPULATION, Set.of("p1", "p2", "p3"), dateBasis);

        PopulationDef measurePopulation = createPopulationDef(
                "mp-1", MeasurePopulationType.MEASUREPOPULATION, Set.of("p1", "p2", "p3"), dateBasis);

        // Create MEASUREOBSERVATION population with QuantityDef observations
        // Default aggregation method is SUM when not specified
        ConceptDef measureObsCode = createMeasurePopulationConcept(MeasurePopulationType.MEASUREOBSERVATION);
        PopulationDef measureObsPop = new PopulationDef(
                "msrobs-1",
                measureObsCode,
                MeasurePopulationType.MEASUREOBSERVATION,
                "expression",
                dateBasis,
                null,
                ContinuousVariableObservationAggregateMethod.SUM);

        // Add QuantityDef observations for each subject
        Map<String, QuantityDef> obs1 = new HashMap<>();
        obs1.put("obs-1", new QuantityDef(10.0));
        measureObsPop.addResource("p1", obs1);

        Map<String, QuantityDef> obs2 = new HashMap<>();
        obs2.put("obs-2", new QuantityDef(20.0));
        measureObsPop.addResource("p2", obs2);

        Map<String, QuantityDef> obs3 = new HashMap<>();
        obs3.put("obs-3", new QuantityDef(30.0));
        measureObsPop.addResource("p3", obs3);

        GroupDef groupDef = new GroupDef(
                "group-1",
                createTextOnlyConcept("Test Group"),
                List.of(),
                List.of(initialPopulation, measurePopulation, measureObsPop),
                MeasureScoring.CONTINUOUSVARIABLE,
                false,
                createImprovementNotationCode("increase"),
                dateBasis);

        assertNull(groupDef.getScore());

        MeasureDefScorer scorer = new MeasureDefScorer();
        scorer.scoreGroup("http://example.com/Measure/test", groupDef);

        // VERIFY: SUM aggregation = 60.0
        assertEquals(60.0, groupDef.getScore(), 0.001);
    }

    @Test
    void testScoreGroup_ContinuousVariable_AvgAggregation() {
        // Setup: Continuous variable measure with AVG aggregation
        // Subject observations: 10.0, 20.0, 30.0 = 20.0 average
        CodeDef booleanBasis = createBooleanBasisCode();
        PopulationDef initialPopulation = createPopulationDef(
                "ip-1", MeasurePopulationType.INITIALPOPULATION, Set.of("p1", "p2", "p3"), booleanBasis);

        PopulationDef measurePopulation = createPopulationDef(
                "mp-1", MeasurePopulationType.MEASUREPOPULATION, Set.of("p1", "p2", "p3"), booleanBasis);

        ConceptDef measureObsCode = createMeasurePopulationConcept(MeasurePopulationType.MEASUREOBSERVATION);
        PopulationDef measureObsPop = new PopulationDef(
                "msrobs-1",
                measureObsCode,
                MeasurePopulationType.MEASUREOBSERVATION,
                "expression",
                booleanBasis,
                null,
                ContinuousVariableObservationAggregateMethod.AVG);

        Map<String, QuantityDef> obs1 = new HashMap<>();
        obs1.put("obs-1", new QuantityDef(10.0));
        measureObsPop.addResource("p1", obs1);

        Map<String, QuantityDef> obs2 = new HashMap<>();
        obs2.put("obs-2", new QuantityDef(20.0));
        measureObsPop.addResource("p2", obs2);

        Map<String, QuantityDef> obs3 = new HashMap<>();
        obs3.put("obs-3", new QuantityDef(30.0));
        measureObsPop.addResource("p3", obs3);

        GroupDef groupDef = new GroupDef(
                "group-1",
                createTextOnlyConcept("Test Group"),
                List.of(),
                List.of(initialPopulation, measurePopulation, measureObsPop),
                MeasureScoring.CONTINUOUSVARIABLE,
                false,
                createImprovementNotationCode("increase"),
                booleanBasis);

        assertNull(groupDef.getScore());

        MeasureDefScorer scorer = new MeasureDefScorer();
        scorer.scoreGroup("http://example.com/Measure/test", groupDef);

        // VERIFY: AVG aggregation = 20.0
        assertEquals(20.0, groupDef.getScore(), 0.001);
    }

    @Test
    void testScoreGroup_ContinuousVariable_MinAggregation() {
        // Setup: Continuous variable with MIN aggregation
        // Subject observations: 10.0, 20.0, 30.0 = 10.0 min
        CodeDef encounterBasis = createPopulationBasisCode("Encounter");
        PopulationDef initialPopulation = createPopulationDef(
                "ip-1", MeasurePopulationType.INITIALPOPULATION, Set.of("p1", "p2", "p3"), encounterBasis);

        PopulationDef measurePopulation = createPopulationDef(
                "mp-1", MeasurePopulationType.MEASUREPOPULATION, Set.of("p1", "p2", "p3"), encounterBasis);

        ConceptDef measureObsCode = createMeasurePopulationConcept(MeasurePopulationType.MEASUREOBSERVATION);
        PopulationDef measureObsPop = new PopulationDef(
                "msrobs-1",
                measureObsCode,
                MeasurePopulationType.MEASUREOBSERVATION,
                "expression",
                encounterBasis,
                null,
                ContinuousVariableObservationAggregateMethod.MIN);

        Map<String, QuantityDef> obs1 = new HashMap<>();
        obs1.put("obs-1", new QuantityDef(10.0));
        measureObsPop.addResource("p1", obs1);

        Map<String, QuantityDef> obs2 = new HashMap<>();
        obs2.put("obs-2", new QuantityDef(20.0));
        measureObsPop.addResource("p2", obs2);

        Map<String, QuantityDef> obs3 = new HashMap<>();
        obs3.put("obs-3", new QuantityDef(30.0));
        measureObsPop.addResource("p3", obs3);

        GroupDef groupDef = new GroupDef(
                "group-1",
                createTextOnlyConcept("Test Group"),
                List.of(),
                List.of(initialPopulation, measurePopulation, measureObsPop),
                MeasureScoring.CONTINUOUSVARIABLE,
                false,
                createImprovementNotationCode("increase"),
                encounterBasis);

        assertNull(groupDef.getScore());

        MeasureDefScorer scorer = new MeasureDefScorer();
        scorer.scoreGroup("http://example.com/Measure/test", groupDef);

        // VERIFY: MIN aggregation = 10.0
        assertEquals(10.0, groupDef.getScore(), 0.001);
    }

    @Test
    void testScoreGroup_ContinuousVariable_MaxAggregation() {
        // Setup: Continuous variable with MAX aggregation
        // Subject observations: 10.0, 20.0, 30.0 = 30.0 max
        CodeDef stringBasis = createPopulationBasisCode("String");
        PopulationDef initialPopulation = createPopulationDef(
                "ip-1", MeasurePopulationType.INITIALPOPULATION, Set.of("p1", "p2", "p3"), stringBasis);

        PopulationDef measurePopulation = createPopulationDef(
                "mp-1", MeasurePopulationType.MEASUREPOPULATION, Set.of("p1", "p2", "p3"), stringBasis);

        ConceptDef measureObsCode = createMeasurePopulationConcept(MeasurePopulationType.MEASUREOBSERVATION);
        PopulationDef measureObsPop = new PopulationDef(
                "msrobs-1",
                measureObsCode,
                MeasurePopulationType.MEASUREOBSERVATION,
                "expression",
                stringBasis,
                null,
                ContinuousVariableObservationAggregateMethod.MAX);

        Map<String, QuantityDef> obs1 = new HashMap<>();
        obs1.put("obs-1", new QuantityDef(10.0));
        measureObsPop.addResource("p1", obs1);

        Map<String, QuantityDef> obs2 = new HashMap<>();
        obs2.put("obs-2", new QuantityDef(20.0));
        measureObsPop.addResource("p2", obs2);

        Map<String, QuantityDef> obs3 = new HashMap<>();
        obs3.put("obs-3", new QuantityDef(30.0));
        measureObsPop.addResource("p3", obs3);

        GroupDef groupDef = new GroupDef(
                "group-1",
                createTextOnlyConcept("Test Group"),
                List.of(),
                List.of(initialPopulation, measurePopulation, measureObsPop),
                MeasureScoring.CONTINUOUSVARIABLE,
                false,
                createImprovementNotationCode("increase"),
                stringBasis);

        assertNull(groupDef.getScore());

        MeasureDefScorer scorer = new MeasureDefScorer();
        scorer.scoreGroup("http://example.com/Measure/test", groupDef);

        // VERIFY: MAX aggregation = 30.0
        assertEquals(30.0, groupDef.getScore(), 0.001);
    }

    // ============================================================================
    // GroupDef.getMeasureScore() Tests - Improvement Notation Adjustment
    // ============================================================================

    @Test
    void testGetMeasureScore_NullScore() {
        // Setup: Group with no scoring performed (score is null)
        CodeDef dateBasis = createPopulationBasisCode("date");
        PopulationDef numeratorPop = createPopulationDef(
                "num-1", MeasurePopulationType.NUMERATOR, Set.of("patient1", "patient2", "patient3"), dateBasis);
        PopulationDef denominatorPop = createPopulationDef(
                "den-1",
                MeasurePopulationType.DENOMINATOR,
                Set.of("patient1", "patient2", "patient3", "patient4"),
                dateBasis);

        GroupDef groupDef = new GroupDef(
                "group-1",
                createTextOnlyConcept("Test Group"),
                List.of(),
                List.of(numeratorPop, denominatorPop),
                MeasureScoring.PROPORTION,
                false,
                createImprovementNotationCode("increase"),
                dateBasis);

        // VERIFY: getMeasureScore returns null when score is null
        assertNull(groupDef.getScore());
        assertNull(groupDef.getMeasureScore());
    }

    @Test
    void testGetMeasureScore_ZeroScore_IncreaseNotation() {
        // Setup: Group with zero score and increase notation
        CodeDef encounterBasis = createPopulationBasisCode("Encounter");
        PopulationDef numeratorPop =
                createPopulationDef("num-1", MeasurePopulationType.NUMERATOR, Set.of(), encounterBasis); // No subjects
        PopulationDef denominatorPop = createPopulationDef(
                "den-1",
                MeasurePopulationType.DENOMINATOR,
                Set.of("patient1", "patient2", "patient3", "patient4"),
                encounterBasis);

        GroupDef groupDef = new GroupDef(
                "group-1",
                createTextOnlyConcept("Test Group"),
                List.of(),
                List.of(numeratorPop, denominatorPop),
                MeasureScoring.PROPORTION,
                false,
                createImprovementNotationCode("increase"),
                encounterBasis);

        MeasureDefScorer scorer = new MeasureDefScorer();
        scorer.scoreGroup("http://example.com/Measure/test", groupDef);

        // VERIFY: Score is 0/4 = 0.0
        assertEquals(0.0, groupDef.getScore(), 0.001);
        // VERIFY: getMeasureScore returns 0.0 for increase notation
        assertEquals(0.0, groupDef.getMeasureScore(), 0.001);
    }

    @Test
    void testGetMeasureScore_NegativeScore_ReturnsNull() {
        // Setup: Group with manually set negative score (simulating applySetMembership=false scenario)
        CodeDef stringBasis = createPopulationBasisCode("String");
        PopulationDef numeratorPop = createPopulationDef(
                "num-1", MeasurePopulationType.NUMERATOR, Set.of("patient1", "patient2", "patient3"), stringBasis);
        PopulationDef denominatorPop = createPopulationDef(
                "den-1",
                MeasurePopulationType.DENOMINATOR,
                Set.of("patient1", "patient2", "patient3", "patient4"),
                stringBasis);

        GroupDef groupDef = new GroupDef(
                "group-1",
                createTextOnlyConcept("Test Group"),
                List.of(),
                List.of(numeratorPop, denominatorPop),
                MeasureScoring.PROPORTION,
                false,
                createImprovementNotationCode("increase"),
                stringBasis);

        // Manually set negative score to simulate strange value scenario
        groupDef.setScore(-0.5);

        // VERIFY: getScore returns the negative value
        assertEquals(-0.5, groupDef.getScore(), 0.001);
        // VERIFY: getMeasureScore returns null for negative scores
        assertNull(groupDef.getMeasureScore());
    }

    @Test
    void testGetMeasureScore_PositiveScore_IncreaseNotation() {
        // Setup: Group with positive score and increase notation
        CodeDef dateBasis = createPopulationBasisCode("date");
        PopulationDef numeratorPop = createPopulationDef(
                "num-1", MeasurePopulationType.NUMERATOR, Set.of("patient1", "patient2", "patient3"), dateBasis);
        PopulationDef denominatorPop = createPopulationDef(
                "den-1",
                MeasurePopulationType.DENOMINATOR,
                Set.of("patient1", "patient2", "patient3", "patient4"),
                dateBasis);

        GroupDef groupDef = new GroupDef(
                "group-1",
                createTextOnlyConcept("Test Group"),
                List.of(),
                List.of(numeratorPop, denominatorPop),
                MeasureScoring.PROPORTION,
                false,
                createImprovementNotationCode("increase"),
                dateBasis);

        MeasureDefScorer scorer = new MeasureDefScorer();
        scorer.scoreGroup("http://example.com/Measure/test", groupDef);

        // VERIFY: Score is 3/4 = 0.75
        assertEquals(0.75, groupDef.getScore(), 0.001);
        // VERIFY: getMeasureScore returns score as-is for increase notation
        assertEquals(0.75, groupDef.getMeasureScore(), 0.001);
    }

    @Test
    void testGetMeasureScore_PositiveScore_DecreaseNotation() {
        // Setup: Group with positive score and decrease notation
        CodeDef booleanBasis = createBooleanBasisCode();
        PopulationDef numeratorPop = createPopulationDef(
                "num-1", MeasurePopulationType.NUMERATOR, Set.of("patient1", "patient2", "patient3"), booleanBasis);
        PopulationDef denominatorPop = createPopulationDef(
                "den-1",
                MeasurePopulationType.DENOMINATOR,
                Set.of("patient1", "patient2", "patient3", "patient4"),
                booleanBasis);

        GroupDef groupDef = new GroupDef(
                "group-1",
                createTextOnlyConcept("Test Group"),
                List.of(),
                List.of(numeratorPop, denominatorPop),
                MeasureScoring.PROPORTION,
                false,
                createImprovementNotationCode("decrease"), // DECREASE notation
                booleanBasis);

        MeasureDefScorer scorer = new MeasureDefScorer();
        scorer.scoreGroup("http://example.com/Measure/test", groupDef);

        // VERIFY: Score is 3/4 = 0.75
        assertEquals(0.75, groupDef.getScore(), 0.001);
        // VERIFY: getMeasureScore returns (1 - score) = 0.25 for decrease notation
        assertEquals(0.25, groupDef.getMeasureScore(), 0.001);
    }

    // ============================================================================
    // Population Basis Tests - Boolean vs Non-Boolean Counting
    // ============================================================================

    /**
     * Test that demonstrates population basis "boolean" counts unique subjects.
     * <p>
     * With boolean basis, PopulationDef.getCount() calls getSubjects().size().
     * Even if a subject has multiple resources, they are counted only once.
     * <p>
     * This test has:
     * - Numerator: 2 subjects (patient1 with 3 encounters, patient2 with 2 encounters)
     * - Denominator: 3 subjects (patient1, patient2, patient3 each with multiple encounters)
     * - Expected score: 2 subjects / 3 subjects = 0.667
     */
    @Test
    void testScoreGroup_BooleanBasis_CountsUniqueSubjects() {
        // Create numerator with 2 subjects, each having multiple resources
        ConceptDef numeratorCode = createMeasurePopulationConcept(MeasurePopulationType.NUMERATOR);
        CodeDef booleanBasis = createBooleanBasisCode();
        PopulationDef numeratorPop =
                new PopulationDef("num-1", numeratorCode, MeasurePopulationType.NUMERATOR, "Numerator", booleanBasis);

        // Patient1: 3 encounters in numerator
        numeratorPop.addResource("patient1", "Encounter/enc1");
        numeratorPop.addResource("patient1", "Encounter/enc2");
        numeratorPop.addResource("patient1", "Encounter/enc3");

        // Patient2: 2 encounters in numerator
        numeratorPop.addResource("patient2", "Encounter/enc4");
        numeratorPop.addResource("patient2", "Encounter/enc5");

        // Create denominator with 3 subjects, each having multiple resources
        ConceptDef denominatorCode = createMeasurePopulationConcept(MeasurePopulationType.DENOMINATOR);
        CodeDef booleanBasis2 = createBooleanBasisCode();
        PopulationDef denominatorPop = new PopulationDef(
                "den-1", denominatorCode, MeasurePopulationType.DENOMINATOR, "Denominator", booleanBasis2);

        // Patient1: 3 encounters in denominator
        denominatorPop.addResource("patient1", "Encounter/enc1");
        denominatorPop.addResource("patient1", "Encounter/enc2");
        denominatorPop.addResource("patient1", "Encounter/enc3");

        // Patient2: 2 encounters in denominator
        denominatorPop.addResource("patient2", "Encounter/enc4");
        denominatorPop.addResource("patient2", "Encounter/enc5");

        // Patient3: 4 encounters in denominator (NOT in numerator)
        denominatorPop.addResource("patient3", "Encounter/enc6");
        denominatorPop.addResource("patient3", "Encounter/enc7");
        denominatorPop.addResource("patient3", "Encounter/enc8");
        denominatorPop.addResource("patient3", "Encounter/enc9");

        // CRITICAL: Use boolean basis
        GroupDef groupDef = new GroupDef(
                "group-1",
                createTextOnlyConcept("Boolean Basis Test"),
                List.of(),
                List.of(numeratorPop, denominatorPop),
                MeasureScoring.PROPORTION,
                false,
                createImprovementNotationCode("increase"),
                createPopulationBasisCode("boolean"));

        // Verify counts BEFORE scoring
        // Boolean basis: count unique subjects, NOT resources
        assertEquals(2, numeratorPop.getCount()); // 2 subjects (patient1, patient2)
        assertEquals(3, denominatorPop.getCount()); // 3 subjects (patient1, patient2, patient3)

        // Execute scoring
        MeasureDefScorer scorer = new MeasureDefScorer();
        scorer.scoreGroup("http://example.com/Measure/test", groupDef);

        // VERIFY: Score is based on unique subjects, NOT resources
        // 2 subjects / 3 subjects = 0.667
        assertEquals(0.667, groupDef.getScore(), 0.001);
    }

    /**
     * Test that demonstrates non-boolean basis counts all subject resources.
     * <p>
     * With Encounter basis, PopulationDef.getCount() calls getAllSubjectResources().size().
     * Each resource is counted, even if multiple resources belong to the same subject.
     * <p>
     * This test uses the SAME population setup as testScoreGroup_BooleanBasis_CountsUniqueSubjects
     * but with "Encounter" basis instead of "boolean".
     * <p>
     * Expected:
     * - Numerator: 5 encounters (3 for patient1 + 2 for patient2)
     * - Denominator: 9 encounters (3 for patient1 + 2 for patient2 + 4 for patient3)
     * - Expected score: 5 encounters / 9 encounters = 0.556
     */
    @Test
    void testScoreGroup_EncounterBasis_CountsAllResources() {
        // Create numerator with 2 subjects, each having multiple resources
        ConceptDef numeratorCode = createMeasurePopulationConcept(MeasurePopulationType.NUMERATOR);
        CodeDef encounterBasis = createPopulationBasisCode("Encounter");
        PopulationDef numeratorPop =
                new PopulationDef("num-1", numeratorCode, MeasurePopulationType.NUMERATOR, "Numerator", encounterBasis);

        // Patient1: 3 encounters in numerator
        numeratorPop.addResource("patient1", "Encounter/enc1");
        numeratorPop.addResource("patient1", "Encounter/enc2");
        numeratorPop.addResource("patient1", "Encounter/enc3");

        // Patient2: 2 encounters in numerator
        numeratorPop.addResource("patient2", "Encounter/enc4");
        numeratorPop.addResource("patient2", "Encounter/enc5");

        // Create denominator with 3 subjects, each having multiple resources
        ConceptDef denominatorCode = createMeasurePopulationConcept(MeasurePopulationType.DENOMINATOR);
        PopulationDef denominatorPop = new PopulationDef(
                "den-1", denominatorCode, MeasurePopulationType.DENOMINATOR, "Denominator", encounterBasis);

        // Patient1: 3 encounters in denominator
        denominatorPop.addResource("patient1", "Encounter/enc1");
        denominatorPop.addResource("patient1", "Encounter/enc2");
        denominatorPop.addResource("patient1", "Encounter/enc3");

        // Patient2: 2 encounters in denominator
        denominatorPop.addResource("patient2", "Encounter/enc4");
        denominatorPop.addResource("patient2", "Encounter/enc5");

        // Patient3: 4 encounters in denominator (NOT in numerator)
        denominatorPop.addResource("patient3", "Encounter/enc6");
        denominatorPop.addResource("patient3", "Encounter/enc7");
        denominatorPop.addResource("patient3", "Encounter/enc8");
        denominatorPop.addResource("patient3", "Encounter/enc9");

        // CRITICAL: Use Encounter basis (non-boolean)
        GroupDef groupDef = new GroupDef(
                "group-1",
                createTextOnlyConcept("Encounter Basis Test"),
                List.of(),
                List.of(numeratorPop, denominatorPop),
                MeasureScoring.PROPORTION,
                false,
                createImprovementNotationCode("increase"),
                encounterBasis);

        // Verify counts BEFORE scoring
        // Encounter basis: count ALL resources, not just unique subjects
        assertEquals(5, numeratorPop.getCount()); // 5 encounters (3 + 2)
        assertEquals(9, denominatorPop.getCount()); // 9 encounters (3 + 2 + 4)

        // Execute scoring
        MeasureDefScorer scorer = new MeasureDefScorer();
        scorer.scoreGroup("http://example.com/Measure/test", groupDef);

        // VERIFY: Score is based on encounter count, NOT subject count
        // 5 encounters / 9 encounters = 0.556
        assertEquals(0.556, groupDef.getScore(), 0.001);
    }

    // ============================================================================
    // Additional Test Coverage - Cohort and Edge Cases
    // ============================================================================

    @Test
    void testScoreGroup_CohortMeasure_NoScoreSet() {
        // Setup: Cohort measure with only INITIALPOPULATION
        CodeDef booleanBasis = createBooleanBasisCode();
        PopulationDef initialPopulation = createPopulationDef(
                "ip-1",
                MeasurePopulationType.INITIALPOPULATION,
                Set.of("p1", "p2", "p3", "p4", "p5", "p6", "p7", "p8", "p9", "p10"),
                booleanBasis);

        GroupDef groupDef = new GroupDef(
                "group-1",
                createTextOnlyConcept("Cohort Measure Test"),
                List.of(), // No stratifiers
                List.of(initialPopulation),
                MeasureScoring.COHORT,
                false,
                createImprovementNotationCode("increase"),
                booleanBasis);

        // Verify score is null before scoring
        assertNull(groupDef.getScore());

        // Execute
        MeasureDefScorer scorer = new MeasureDefScorer();
        scorer.scoreGroup("http://example.com/Measure/cohort-test", groupDef);

        // VERIFY: Cohort measures do not have scores
        assertNull(groupDef.getScore());
        assertNull(groupDef.getMeasureScore());
    }

    @Test
    void testScoreGroup_MissingScoringType_ThrowsException() {
        // Setup: GroupDef with null scoring type
        CodeDef booleanBasis = createBooleanBasisCode();
        PopulationDef numeratorPop =
                createPopulationDef("num-1", MeasurePopulationType.NUMERATOR, Set.of("p1", "p2", "p3"), booleanBasis);
        PopulationDef denominatorPop = createPopulationDef(
                "den-1", MeasurePopulationType.DENOMINATOR, Set.of("p1", "p2", "p3", "p4"), booleanBasis);

        GroupDef groupDef = new GroupDef(
                "group-1",
                createTextOnlyConcept("Missing Scoring Type Test"),
                List.of(),
                List.of(numeratorPop, denominatorPop),
                null, // NULL scoring type
                false,
                createImprovementNotationCode("increase"),
                booleanBasis);

        // Execute and verify exception
        MeasureDefScorer scorer = new MeasureDefScorer();

        Exception exception = assertThrows(
                Exception.class, () -> scorer.scoreGroup("http://example.com/Measure/missing-scoring", groupDef));

        // Verify exception message contains useful information
        assertTrue(exception.getMessage().contains("scoring"));
    }

    // ============================================================================
    // Ratio with Observations Tests - Group and Stratum Level
    // ============================================================================

    @Test
    void testScoreGroup_RatioWithObservations_GroupLevel() {
        // Setup: RATIO measure with separate numerator/denominator MEASUREOBSERVATION populations
        CodeDef booleanBasis = createBooleanBasisCode();
        PopulationDef initialPopulation = createPopulationDef(
                "ip-1", MeasurePopulationType.INITIALPOPULATION, Set.of("p1", "p2", "p3"), booleanBasis);
        PopulationDef measurePopulation = createPopulationDef(
                "mp-1", MeasurePopulationType.MEASUREPOPULATION, Set.of("p1", "p2", "p3"), booleanBasis);

        // Create standard NUMERATOR and DENOMINATOR populations (referenced by measure observations)
        PopulationDef numeratorPop =
                createPopulationDef("num-1", MeasurePopulationType.NUMERATOR, Set.of("p1", "p2", "p3"), booleanBasis);
        PopulationDef denominatorPop =
                createPopulationDef("den-1", MeasurePopulationType.DENOMINATOR, Set.of("p1", "p2", "p3"), booleanBasis);

        // Create numerator MEASUREOBSERVATION with criteriaReference to numerator
        ConceptDef numObsCode = createMeasurePopulationConcept(MeasurePopulationType.MEASUREOBSERVATION);
        PopulationDef numeratorMeasureObs = new PopulationDef(
                "num-obs-1",
                numObsCode,
                MeasurePopulationType.MEASUREOBSERVATION,
                "NumeratorExpression",
                booleanBasis,
                "num-1", // criteriaReference to NUMERATOR population
                ContinuousVariableObservationAggregateMethod.SUM);

        // Add numerator observations
        Map<String, QuantityDef> numObs1 = new HashMap<>();
        numObs1.put("obs-num-1", new QuantityDef(10.0));
        numeratorMeasureObs.addResource("p1", numObs1);

        Map<String, QuantityDef> numObs2 = new HashMap<>();
        numObs2.put("obs-num-2", new QuantityDef(20.0));
        numeratorMeasureObs.addResource("p2", numObs2);

        Map<String, QuantityDef> numObs3 = new HashMap<>();
        numObs3.put("obs-num-3", new QuantityDef(30.0));
        numeratorMeasureObs.addResource("p3", numObs3);

        // Create denominator MEASUREOBSERVATION with criteriaReference to denominator
        ConceptDef denObsCode = createMeasurePopulationConcept(MeasurePopulationType.MEASUREOBSERVATION);
        PopulationDef denominatorMeasureObs = new PopulationDef(
                "den-obs-1",
                denObsCode,
                MeasurePopulationType.MEASUREOBSERVATION,
                "DenominatorExpression",
                booleanBasis,
                "den-1", // criteriaReference to DENOMINATOR population
                ContinuousVariableObservationAggregateMethod.SUM);

        // Add denominator observations
        Map<String, QuantityDef> denObs1 = new HashMap<>();
        denObs1.put("obs-den-1", new QuantityDef(5.0));
        denominatorMeasureObs.addResource("p1", denObs1);

        Map<String, QuantityDef> denObs2 = new HashMap<>();
        denObs2.put("obs-den-2", new QuantityDef(10.0));
        denominatorMeasureObs.addResource("p2", denObs2);

        Map<String, QuantityDef> denObs3 = new HashMap<>();
        denObs3.put("obs-den-3", new QuantityDef(15.0));
        denominatorMeasureObs.addResource("p3", denObs3);

        // Create GroupDef with RATIO scoring
        GroupDef groupDef = new GroupDef(
                "group-1",
                createTextOnlyConcept("Ratio with Observations Test"),
                List.of(), // No stratifiers
                List.of(
                        initialPopulation,
                        measurePopulation,
                        numeratorPop,
                        denominatorPop,
                        numeratorMeasureObs,
                        denominatorMeasureObs),
                MeasureScoring.RATIO,
                false,
                createImprovementNotationCode("increase"),
                booleanBasis);

        // Verify score is null before scoring
        assertNull(groupDef.getScore());

        // Execute
        MeasureDefScorer scorer = new MeasureDefScorer();
        scorer.scoreGroup("http://example.com/Measure/ratio-obs-test", groupDef);

        // VERIFY: Score is 60.0 / 30.0 = 2.0
        assertEquals(2.0, groupDef.getScore(), 0.001);
        assertEquals(2.0, groupDef.getMeasureScore(), 0.001);
    }

    @Test
    void testScoreStratifier_RatioWithObservations_StratumLevel() {
        // Setup: Ratio measure with stratifier by gender
        // Male patients: p1, p2, p3
        // Female patients: p4, p5

        CodeDef booleanBasis = createBooleanBasisCode();
        PopulationDef initialPopulation = createPopulationDef(
                "ip-1", MeasurePopulationType.INITIALPOPULATION, Set.of("p1", "p2", "p3", "p4", "p5"), booleanBasis);

        // Create standard NUMERATOR and DENOMINATOR populations
        PopulationDef numeratorPop = createPopulationDef(
                "num-1", MeasurePopulationType.NUMERATOR, Set.of("p1", "p2", "p3", "p4", "p5"), booleanBasis);
        PopulationDef denominatorPop = createPopulationDef(
                "den-1", MeasurePopulationType.DENOMINATOR, Set.of("p1", "p2", "p3", "p4", "p5"), booleanBasis);

        // Create numerator MEASUREOBSERVATION
        ConceptDef numObsCode = createMeasurePopulationConcept(MeasurePopulationType.MEASUREOBSERVATION);
        PopulationDef numeratorMeasureObs = new PopulationDef(
                "num-obs-1",
                numObsCode,
                MeasurePopulationType.MEASUREOBSERVATION,
                "NumeratorExpression",
                booleanBasis,
                "num-1",
                ContinuousVariableObservationAggregateMethod.SUM);

        // Male numerator observations: 10 + 15 + 15 = 40
        Map<String, QuantityDef> numObs1 = new HashMap<>();
        numObs1.put("p1", new QuantityDef(10.0));
        numeratorMeasureObs.addResource("p1", numObs1);

        Map<String, QuantityDef> numObs2 = new HashMap<>();
        numObs2.put("p2", new QuantityDef(15.0));
        numeratorMeasureObs.addResource("p2", numObs2);

        Map<String, QuantityDef> numObs3 = new HashMap<>();
        numObs3.put("p3", new QuantityDef(15.0));
        numeratorMeasureObs.addResource("p3", numObs3);

        // Female numerator observations: 10 + 20 = 30
        Map<String, QuantityDef> numObs4 = new HashMap<>();
        numObs4.put("p4", new QuantityDef(10.0));
        numeratorMeasureObs.addResource("p4", numObs4);

        Map<String, QuantityDef> numObs5 = new HashMap<>();
        numObs5.put("p5", new QuantityDef(20.0));
        numeratorMeasureObs.addResource("p5", numObs5);

        // Create denominator MEASUREOBSERVATION
        ConceptDef denObsCode = createMeasurePopulationConcept(MeasurePopulationType.MEASUREOBSERVATION);
        PopulationDef denominatorMeasureObs = new PopulationDef(
                "den-obs-1",
                denObsCode,
                MeasurePopulationType.MEASUREOBSERVATION,
                "DenominatorExpression",
                booleanBasis,
                "den-1",
                ContinuousVariableObservationAggregateMethod.SUM);

        // Male denominator observations: 5 + 7 + 8 = 20
        Map<String, QuantityDef> denObs1 = new HashMap<>();
        denObs1.put("p1", new QuantityDef(5.0));
        denominatorMeasureObs.addResource("p1", denObs1);

        Map<String, QuantityDef> denObs2 = new HashMap<>();
        denObs2.put("p2", new QuantityDef(7.0));
        denominatorMeasureObs.addResource("p2", denObs2);

        Map<String, QuantityDef> denObs3 = new HashMap<>();
        denObs3.put("p3", new QuantityDef(8.0));
        denominatorMeasureObs.addResource("p3", denObs3);

        // Female denominator observations: 4 + 6 = 10
        Map<String, QuantityDef> denObs4 = new HashMap<>();
        denObs4.put("p4", new QuantityDef(4.0));
        denominatorMeasureObs.addResource("p4", denObs4);

        Map<String, QuantityDef> denObs5 = new HashMap<>();
        denObs5.put("p5", new QuantityDef(6.0));
        denominatorMeasureObs.addResource("p5", denObs5);

        // Create stratum populations for Male stratum
        // Male stratum - MEASUREOBSERVATION populations
        StratumPopulationDef maleNumObs = new StratumPopulationDef(
                numeratorMeasureObs,
                Set.of("p1", "p2", "p3"), // subjectsQualifiedOrUnqualified
                Set.of(), // populationDefEvaluationResultIntersection
                List.of(), // resourceIdsForSubjectList
                MeasureStratifierType.VALUE,
                booleanBasis);

        StratumPopulationDef maleDenObs = new StratumPopulationDef(
                denominatorMeasureObs,
                Set.of("p1", "p2", "p3"),
                Set.of(),
                List.of(),
                MeasureStratifierType.VALUE,
                booleanBasis);

        StratifierComponentDef genderComponent =
                new StratifierComponentDef("gender-component", createTextOnlyConcept("Gender"), "Gender");

        // Create measure observation cache for male stratum
        MeasureObservationStratumCache maleCache = new MeasureObservationStratumCache(maleNumObs, maleDenObs);

        StratumDef maleStratum = new StratumDef(
                List.of(maleNumObs, maleDenObs),
                Set.of(new StratumValueDef(new StratumValueWrapper("male"), genderComponent)),
                Set.of("p1", "p2", "p3"),
                maleCache);

        // Female stratum - MEASUREOBSERVATION populations
        StratumPopulationDef femaleNumObs = new StratumPopulationDef(
                numeratorMeasureObs,
                Set.of("p4", "p5"),
                Set.of(),
                List.of(),
                MeasureStratifierType.VALUE,
                booleanBasis);

        StratumPopulationDef femaleDenObs = new StratumPopulationDef(
                denominatorMeasureObs,
                Set.of("p4", "p5"),
                Set.of(),
                List.of(),
                MeasureStratifierType.VALUE,
                booleanBasis);

        // Create measure observation cache for female stratum
        MeasureObservationStratumCache femaleCache = new MeasureObservationStratumCache(femaleNumObs, femaleDenObs);

        StratumDef femaleStratum = new StratumDef(
                List.of(femaleNumObs, femaleDenObs),
                Set.of(new StratumValueDef(new StratumValueWrapper("female"), genderComponent)),
                Set.of("p4", "p5"),
                femaleCache);

        // Create StratifierDef with strata
        StratifierDef stratifierDef = new StratifierDef(
                "gender-stratifier", createTextOnlyConcept("Gender Stratifier"), "Gender", MeasureStratifierType.VALUE);
        stratifierDef.addAllStratum(List.of(maleStratum, femaleStratum));

        // Create GroupDef
        GroupDef groupDef = new GroupDef(
                "group-1",
                createTextOnlyConcept("Ratio with Observations Stratified"),
                List.of(stratifierDef),
                List.of(initialPopulation, numeratorPop, denominatorPop, numeratorMeasureObs, denominatorMeasureObs),
                MeasureScoring.RATIO,
                false,
                createImprovementNotationCode("increase"),
                booleanBasis);

        // Verify scores are null before scoring
        assertNull(maleStratum.getScore());
        assertNull(femaleStratum.getScore());

        // Execute
        MeasureDefScorer scorer = new MeasureDefScorer();
        scorer.scoreGroup("http://example.com/Measure/ratio-obs-stratified", groupDef);

        // VERIFY: Male stratum score = 40/20 = 2.0
        assertEquals(2.0, maleStratum.getScore(), 0.001);

        // VERIFY: Female stratum score = 30/10 = 3.0
        assertEquals(3.0, femaleStratum.getScore(), 0.001);
    }

    // ============================================================================
    // Helper Methods for Test Data Construction
    // ============================================================================

    /**
     * Create PopulationDef with subjects and specified population basis.
     * The populationBasis CodeDef should be the SAME instance used for the GroupDef.
     */
    private PopulationDef createPopulationDef(
            String id, MeasurePopulationType type, Set<String> subjects, CodeDef populationBasis) {
        ConceptDef code = createMeasurePopulationConcept(type);
        PopulationDef pop = new PopulationDef(id, code, type, "expression", populationBasis);

        // Add subjects to population
        for (String subject : subjects) {
            pop.addResource(subject, true); // For boolean basis, resource is just boolean true
        }

        return pop;
    }

    /**
     * Create CodeDef for boolean population basis.
     */
    private CodeDef createBooleanBasisCode() {
        return new CodeDef("http://hl7.org/fhir/fhir-types", "boolean");
    }

    /**
     * Create CodeDef for measure-population system.
     */
    private CodeDef createMeasurePopulationCode(String code) {
        return new CodeDef("http://terminology.hl7.org/CodeSystem/measure-population", code);
    }

    /**
     * Create CodeDef for measure-improvement-notation system.
     */
    private CodeDef createImprovementNotationCode(String notation) {
        return new CodeDef("http://terminology.hl7.org/CodeSystem/measure-improvement-notation", notation);
    }

    /**
     * Create CodeDef for measure population basis.
     */
    private CodeDef createPopulationBasisCode(String basis) {
        return new CodeDef("http://hl7.org/fhir/ValueSet/measure-population", basis);
    }

    /**
     * Create ConceptDef for measure population type.
     */
    private ConceptDef createMeasurePopulationConcept(MeasurePopulationType type) {
        return new ConceptDef(List.of(createMeasurePopulationCode(type.toCode())), type.toCode());
    }

    /**
     * Create ConceptDef with text only (no codes).
     */
    private ConceptDef createTextOnlyConcept(String text) {
        return new ConceptDef(List.of(), text);
    }

    @Test
    void testScoreStratifier_QualifiedVsUnqualifiedSubjectIds() {
        // Setup: Group with stratifier where StratumPopulationDef uses qualified IDs
        // but PopulationDef.subjectResources uses unqualified IDs

        CodeDef booleanBasis = createBooleanBasisCode();

        // Create populations with UNQUALIFIED subject IDs
        PopulationDef numeratorPop = createPopulationDef(
                "num-1",
                MeasurePopulationType.NUMERATOR,
                Set.of("patient-1965-female", "patient-1966-female", "patient-1967-male"),
                booleanBasis);

        PopulationDef denominatorPop = createPopulationDef(
                "den-1",
                MeasurePopulationType.DENOMINATOR,
                Set.of("patient-1965-female", "patient-1966-female", "patient-1967-male", "patient-1968-male"),
                booleanBasis);

        // Create stratum populations with QUALIFIED subject IDs (e.g., "Patient/patient-1965-female")
        // Female stratum: 2 numerator / 2 denominator = 1.0
        StratumPopulationDef femaleNumPop = new StratumPopulationDef(
                numeratorPop,
                Set.of("Patient/patient-1965-female", "Patient/patient-1966-female"), // QUALIFIED IDs
                Set.of(),
                List.of(),
                MeasureStratifierType.VALUE,
                booleanBasis);

        StratumPopulationDef femaleDenPop = new StratumPopulationDef(
                denominatorPop,
                Set.of("Patient/patient-1965-female", "Patient/patient-1966-female"), // QUALIFIED IDs
                Set.of(),
                List.of(),
                MeasureStratifierType.VALUE,
                booleanBasis);

        StratifierComponentDef genderComponent =
                new StratifierComponentDef("gender-component", createTextOnlyConcept("Gender"), "Gender");

        StratumDef femaleStratum = new StratumDef(
                List.of(femaleNumPop, femaleDenPop),
                Set.of(new StratumValueDef(new StratumValueWrapper("female"), genderComponent)),
                Set.of("Patient/patient-1965-female", "Patient/patient-1966-female"), // QUALIFIED IDs
                null); // No MeasureObservationStratumCache needed for proportion measures

        // Male stratum: 1 numerator / 2 denominator = 0.5
        StratumPopulationDef maleNumPop = new StratumPopulationDef(
                numeratorPop,
                Set.of("Patient/patient-1967-male"), // QUALIFIED IDs
                Set.of(),
                List.of(),
                MeasureStratifierType.VALUE,
                booleanBasis);

        StratumPopulationDef maleDenPop = new StratumPopulationDef(
                denominatorPop,
                Set.of("Patient/patient-1967-male", "Patient/patient-1968-male"), // QUALIFIED IDs
                Set.of(),
                List.of(),
                MeasureStratifierType.VALUE,
                booleanBasis);

        StratumDef maleStratum = new StratumDef(
                List.of(maleNumPop, maleDenPop),
                Set.of(new StratumValueDef(new StratumValueWrapper("male"), genderComponent)),
                Set.of("Patient/patient-1967-male", "Patient/patient-1968-male"), // QUALIFIED IDs
                null); // No MeasureObservationStratumCache needed for proportion measures

        StratifierDef stratifierDef = new StratifierDef(
                "gender-stratifier", createTextOnlyConcept("Gender Stratifier"), "Gender", MeasureStratifierType.VALUE);
        stratifierDef.addAllStratum(List.of(femaleStratum, maleStratum));

        GroupDef groupDef = new GroupDef(
                "group-1",
                createTextOnlyConcept("Qualified vs Unqualified ID Test"),
                List.of(stratifierDef),
                List.of(numeratorPop, denominatorPop),
                MeasureScoring.PROPORTION,
                false,
                createImprovementNotationCode("increase"),
                booleanBasis);

        // Verify scores are null before scoring
        assertNull(femaleStratum.getScore());
        assertNull(maleStratum.getScore());

        // Execute
        MeasureDefScorer scorer = new MeasureDefScorer();
        scorer.scoreGroup("http://example.com/Measure/qualified-ids-test", groupDef);

        // VERIFY: Scorer correctly matched qualified stratum IDs to unqualified population IDs
        // Female stratum: 2/2 = 1.0
        assertEquals(1.0, femaleStratum.getScore(), 0.001, "Female stratum should have score 1.0 (2/2)");

        // Male stratum: 1/2 = 0.5
        assertEquals(0.5, maleStratum.getScore(), 0.001, "Male stratum should have score 0.5 (1/2)");
    }
}
