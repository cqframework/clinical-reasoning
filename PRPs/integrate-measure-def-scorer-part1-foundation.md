# PRP: Integrate MeasureDefScorer - Part 1: Foundation & Refactoring

## Metadata
- **Title**: MeasureDefScorer Foundation - Refactoring, Testing, and cdr-cr API (No Behavioral Changes)
- **Status**: Planning Complete - Ready for Implementation
- **Priority**: High (Architecture Consolidation)
- **Estimated Effort**: 2-3 days
- **Target Branch**: ld-20251208-integrate-new-measure-scorer
- **Planning Date**: 2025-12-09
- **Dependencies**: None
- **Dependents**: Part 2 (integrate-measure-def-scorer-part2-integration.md)

## Executive Summary

Part 1 establishes the foundation for version-agnostic measure scoring without changing existing behavior. This PRP:
1. Refactors MeasureDefScorer with performance optimizations and COHORT/COMPOSITE support
2. Creates MeasureReportScoringFhirAdapter for external consumers (cdr-cr project)
3. Adds score copying logic to R4/DSTU3 builders (inactive in Part 1, activated in Part 2)
4. Deprecates old scorers while keeping them fully functional
5. Comprehensive unit testing of all new components

**Key Constraint:** Old R4/DSTU3 scorers remain the source of truth for regular measure evaluation. New scoring paths only active in MeasureReportScoringFhirAdapter (cdr-cr API).

**Part 2 Dependency:** Part 2 will activate MeasureDefScorer in MeasureEvaluationResultHandler and remove old scorer calls from builders.

### Strategy
Safe, incremental refactoring with zero behavior change for existing workflows. New API provides immediate value to cdr-cr project.

## Problem Statement

### Current State
- Version-specific scorers (R4MeasureReportScorer, Dstu3MeasureReportScorer)
- cdr-cr project needs version-agnostic post-hoc scoring API
- Scoring logic duplicated across FHIR versions
- Performance optimization needed for stratified ratio measures with observations

### Part 1 Goals
1. **Refactor MeasureDefScorer** - Add RatioMeasureObservationCache, COHORT/COMPOSITE support
2. **Create External API** - MeasureReportScoringFhirAdapter for cdr-cr project
3. **Prepare Builders** - Add score copying methods (inactive, null scores)
4. **Deprecate Old Scorers** - Mark for future removal, keep functional
5. **Comprehensive Testing** - Unit tests for all new components

### Non-Goals (Part 2)
- Integration with MeasureEvaluationResultHandler (Part 2)
- Removing old scorer calls from builders (Part 2)
- Fhir2Def integration tests (Part 2)

## Architecture Overview

### Two Independent Workflows in Part 1

#### Workflow 1: Regular clinical-reasoning Evaluation (Unchanged)
```
MeasureEvaluationResultHandler
  ↓
MeasureMultiSubjectEvaluator (builds Def objects, NO scores)
  ↓
R4MeasureReportBuilder.build()
  ↓
copyScoresFromDef(bc)  ← NEW: Does nothing (null scores in Def objects)
  ↓
measureReportScorer.score()  ← EXISTING: Produces scores (unchanged)
  ↓
MeasureReport with scores ✅
```

#### Workflow 2: cdr-cr Post-hoc Scoring (NEW)
```
cdr-cr retrieves MeasureReport from database (has counts, no scores)
  ↓
MeasureReportScoringFhirAdapter.score(measure, measureReport)
  ↓
Build MeasureDef from Measure structure
  ↓
Populate MeasureDef with counts from MeasureReport
  ↓
MeasureDefScorer.score(measureDef)  ← NEW: Populates Def scores
  ↓
copyScoresToR4Report(measureDef, measureReport)  ← NEW: Copies to report
  ↓
MeasureReport with scores ✅
```

## Implementation Plan

### Phase 1: StratumDef Refactoring for Observation Caching

**Objective:** Eliminate redundant O(n) lookups for measure observation scoring in stratifiers (~36% reduction in operations).

**Tasks:**
1. Create `RatioMeasureObservationCache.java` record class
2. Add `ratioMeasureObservationCache` field to StratumDef (final, immutable)
3. Update StratumDef constructor to take `GroupDef` (4th parameter)
4. Implement `buildRatioMeasureObservationCache(GroupDef)` private method with warning logic
5. Implement `getRatioMeasureObservationCache()` getter
6. Update `MeasureMultiSubjectEvaluator.buildStratumDef()` - remove populationDefs parameter
7. Update `componentStratumPlural()` to pass just groupDef
8. Update `nonComponentStratumPlural()` to pass just groupDef in non-criteria branch
9. Update `MeasureDefScorer.scoreRatioMeasureObservationStratum()` to use getRatioMeasureObservationCache()
10. Update test constructor calls to pass groupDef

**Implementation:**

#### RatioMeasureObservationCache.java
```java
package org.opencds.cqf.fhir.cr.measure.common;

/**
 * Immutable cache holding pre-computed references for ratio measure observation scoring.
 * Used by StratumDef to avoid redundant lookups during scoring.
 *
 * Renamed from MeasureObservationStratumCache to be more specific about ratio measures.
 *
 * Generated by Claude Sonnet 4.5 on 2025-12-09.
 */
public record RatioMeasureObservationCache(
        StratumPopulationDef numeratorObservation,
        StratumPopulationDef denominatorObservation) {

    /**
     * Compact constructor enforcing all-or-nothing semantics.
     */
    public RatioMeasureObservationCache {
        if (numeratorObservation == null || denominatorObservation == null) {
            throw new IllegalArgumentException(
                    "Both numerator and denominator observations must be non-null");
        }
    }
}
```

#### StratumDef.java Updates
```java
public class StratumDef {
    private static final Logger logger = LoggerFactory.getLogger(StratumDef.class);

    private final List<StratumPopulationDef> stratumPopulations;
    private final Set<StratumValueDef> valueDefs;
    private final Collection<String> subjectIds;
    private final RatioMeasureObservationCache ratioMeasureObservationCache;  // Eagerly initialized
    private Double score;

    public StratumDef(
            List<StratumPopulationDef> stratumPopulations,
            Set<StratumValueDef> valueDefs,
            Collection<String> subjectIds,
            GroupDef groupDef) {  // NEW: Pass groupDef instead of pre-built cache
        this.stratumPopulations = List.copyOf(stratumPopulations);
        this.valueDefs = valueDefs;
        this.subjectIds = subjectIds;

        // Eagerly build cache in constructor
        this.ratioMeasureObservationCache = buildRatioMeasureObservationCache(groupDef);
    }

    /**
     * Build ratio measure observation cache if applicable.
     * Returns null if not a ratio measure with observations.
     */
    @Nullable
    private RatioMeasureObservationCache buildRatioMeasureObservationCache(GroupDef groupDef) {
        // Only applicable for measures with MEASUREOBSERVATION populations
        if (!groupDef.hasPopulationType(MeasurePopulationType.MEASUREOBSERVATION)) {
            return null;
        }

        List<PopulationDef> measureObservationPopulationDefs =
            groupDef.getPopulationDefs(MeasurePopulationType.MEASUREOBSERVATION);

        if (measureObservationPopulationDefs.isEmpty()) {
            return null;
        }

        // Find numerator and denominator observation PopulationDefs
        PopulationDef numObsPopDef = groupDef.findRatioObservationPopulationDef(
            measureObservationPopulationDefs,
            MeasurePopulationType.NUMERATOR);
        PopulationDef denObsPopDef = groupDef.findRatioObservationPopulationDef(
            measureObservationPopulationDefs,
            MeasurePopulationType.DENOMINATOR);

        // Warn if only one found (likely configuration error)
        if (numObsPopDef != null && denObsPopDef == null) {
            logger.warn("Found numerator observation but no denominator observation for ratio measure");
            return null;
        }
        if (numObsPopDef == null && denObsPopDef != null) {
            logger.warn("Found denominator observation but no numerator observation for ratio measure");
            return null;
        }

        // Both null or both present
        if (numObsPopDef == null || denObsPopDef == null) {
            return null;
        }

        // Find corresponding StratumPopulationDefs
        StratumPopulationDef numObsStratumPop = stratumPopulations.stream()
            .filter(sp -> sp.populationDef() == numObsPopDef)
            .findFirst()
            .orElse(null);

        StratumPopulationDef denObsStratumPop = stratumPopulations.stream()
            .filter(sp -> sp.populationDef() == denObsPopDef)
            .findFirst()
            .orElse(null);

        // All-or-nothing: only create cache if both found
        if (numObsStratumPop == null || denObsStratumPop == null) {
            return null;
        }

        return new RatioMeasureObservationCache(numObsStratumPop, denObsStratumPop);
    }

    /**
     * Get the ratio measure observation cache (null if not applicable).
     */
    @Nullable
    public RatioMeasureObservationCache getRatioMeasureObservationCache() {
        return ratioMeasureObservationCache;
    }
}
```

**Files Modified:**
- `cqf-fhir-cr/.../common/RatioMeasureObservationCache.java` (CREATE)
- `cqf-fhir-cr/.../common/StratumDef.java`
- `cqf-fhir-cr/.../common/MeasureMultiSubjectEvaluator.java`
- `cqf-fhir-cr/.../common/MeasureDefScorer.java`
- Test files (update constructor calls)

---

### Phase 2: StratumDef Enhancement and COHORT/COMPOSITE Support

**Objective:** Add getMeasureScore() to StratumDef and handle COHORT/COMPOSITE scoring types.

**Tasks:**
1. Add `getMeasureScore()` method to StratumDef (applies improvement notation)
2. Add `COHORT` case to `MeasureDefScorer.calculateGroupScore()` (returns null)
3. Add `COMPOSITE` case to `MeasureDefScorer.calculateGroupScore()` (returns null)
4. Add unit tests for COHORT scoring
5. Add unit tests for COMPOSITE scoring
6. Add unit test for `StratumDef.getMeasureScore()`

**Implementation:**

#### StratumDef.getMeasureScore()
```java
/**
 * Get the measure score for this stratum, applying improvement notation.
 * Mirrors GroupDef.getMeasureScore() behavior.
 *
 * @return the score with improvement notation applied, or null if no score
 */
@Nullable
public Double getMeasureScore() {
    if (this.score == null) {
        return null;
    }

    // Note: Improvement notation applied at GroupDef level, not per-stratum
    // Stratifiers inherit improvement notation from their parent group
    return this.score;
}
```

#### MeasureDefScorer.calculateGroupScore() Updates
```java
@Nullable
private Double calculateGroupScore(String measureUrl, GroupDef groupDef) {
    MeasureScoring measureScoring = groupDef.measureScoring();

    return switch (measureScoring) {
        case PROPORTION, RATIO -> calculateProportionOrRatioScore(measureUrl, groupDef);
        case CONTINUOUSVARIABLE -> calculateContinuousVariableScore(measureUrl, groupDef);
        case COHORT -> null;  // COHORT measures don't have scores
        case COMPOSITE -> null;  // COMPOSITE not yet implemented
        default -> {
            logger.warn("Unsupported measure scoring type: {} for measure: {}", measureScoring, measureUrl);
            yield null;
        }
    };
}
```

**Files Modified:**
- `cqf-fhir-cr/.../common/StratumDef.java`
- `cqf-fhir-cr/.../common/MeasureDefScorer.java`
- `cqf-fhir-cr/src/test/java/.../common/MeasureDefScorerTest.java`

---

### Phase 3: R4 Builder Score Copying Logic

**Objective:** Add score copying methods to R4MeasureReportBuilder. Methods will find null scores and do nothing in Part 1.

**Tasks:**
1. Add `copyScoresFromDef(R4MeasureReportBuilderContext)` method
2. Add `copyStratifierScores()` helper method
3. **Add** copyScoresFromDef() call **before** existing scorer call (line 96)
4. **Keep** existing measureReportScorer.score() call
5. Add unit tests for score copying logic

**Implementation:**

#### R4MeasureReportBuilder.java
```java
@Override
public MeasureReport build(
        Measure measure,
        MeasureDef measureDef,
        MeasureReportType measureReportType,
        Interval measurementPeriod,
        List<String> subjectIds) {

    var report = this.createMeasureReport(measure, measureDef, measureReportType, subjectIds, measurementPeriod);

    var bc = new R4MeasureReportBuilderContext(measure, measureDef, report);

    // buildGroups must be run first to set up the builder context to be able to use
    // the evaluatedResource references for SDE processing
    buildGroups(bc);

    buildSDEs(bc);

    addEvaluatedResource(bc);
    addSupplementalData(bc);
    bc.addOperationOutcomes();

    for (var r : bc.contained().values()) {
        bc.report().addContained(r);
    }

    // NEW: Copy scores from Def objects (Part 1: does nothing, null scores)
    copyScoresFromDef(bc);

    // KEEP: Old scorer still produces scores (Part 1: source of truth)
    this.measureReportScorer.score(measure.getUrl(), measureDef, bc.report());

    setReportStatus(bc);
    return bc.report();
}

/**
 * Copy scores from MeasureDef to MeasureReport.
 * Added in Part 1 (integrate-measure-def-scorer-part1-foundation).
 * In Part 1, this does nothing because Def objects have null scores.
 * In Part 2 (integrate-measure-def-scorer-part2-integration), this becomes active
 * when MeasureDefScorer is called in MeasureEvaluationResultHandler.
 *
 * Logic is driven by Def objects, matching report structures by ID.
 * Logs warnings when matching report structures are not found.
 *
 * @param bc the builder context
 */
private void copyScoresFromDef(R4MeasureReportBuilderContext bc) {
    var report = bc.report();
    var measureDef = bc.measureDef();

    // Iterate through GroupDefs (drive from Def side)
    for (var groupDef : measureDef.groups()) {
        // Find matching report group by ID
        var reportGroup = report.getGroup().stream()
                .filter(rg -> groupDef.id().equals(rg.getId()))
                .findFirst()
                .orElse(null);

        if (reportGroup == null) {
            logger.warn("No matching MeasureReport group found for GroupDef with id: {}", groupDef.id());
            continue;
        }

        // Copy group-level score
        Double groupScore = groupDef.getMeasureScore();
        if (groupScore != null) {
            reportGroup.getMeasureScore().setValue(groupScore);
        }

        // Copy stratifier scores
        copyStratifierScores(reportGroup, groupDef);
    }
}

/**
 * Copy stratifier scores from StratifierDef objects to MeasureReport stratifiers.
 * Logic is driven by StratifierDef objects, matching report stratifiers by ID.
 *
 * @param reportGroup the MeasureReport group component
 * @param groupDef the GroupDef containing stratifier scores
 */
private void copyStratifierScores(MeasureReportGroupComponent reportGroup, GroupDef groupDef) {
    // Iterate through StratifierDefs (drive from Def side)
    for (var stratifierDef : groupDef.stratifiers()) {
        // Find matching report stratifier by ID
        var reportStratifier = reportGroup.getStratifier().stream()
                .filter(rs -> stratifierDef.id().equals(rs.getId()))
                .findFirst()
                .orElse(null);

        if (reportStratifier == null) {
            logger.warn("No matching MeasureReport stratifier found for StratifierDef with id: {}",
                    stratifierDef.id());
            continue;
        }

        // Iterate through StratumDefs (drive from Def side)
        for (var stratumDef : stratifierDef.getStratum()) {
            // Find matching report stratum by comparing value strings
            var reportStratum = reportStratifier.getStratum().stream()
                    .filter(rs -> matchesStratumValue(rs, stratumDef))
                    .findFirst()
                    .orElse(null);

            if (reportStratum == null) {
                logger.debug("No matching MeasureReport stratum found for StratumDef in stratifier: {}",
                        stratifierDef.id());
                continue;
            }

            // Copy stratum score
            Double stratumScore = stratumDef.getMeasureScore();
            if (stratumScore != null) {
                reportStratum.getMeasureScore().setValue(stratumScore);
            }
        }
    }
}

/**
 * Check if a MeasureReport stratum matches a StratumDef by comparing string representations.
 * Uses StratumValueWrapper.getValueAsString() for comparison.
 *
 * @param reportStratum the MeasureReport stratum
 * @param stratumDef the StratumDef
 * @return true if values match
 */
private boolean matchesStratumValue(
        MeasureReport.StratifierGroupComponent reportStratum, StratumDef stratumDef) {
    var stratumValues = stratumDef.valueDefs();

    // Compare component values (for multi-component stratifiers)
    if (reportStratum.hasComponent()) {
        if (stratumValues.size() != reportStratum.getComponent().size()) {
            return false;
        }

        for (var reportComponent : reportStratum.getComponent()) {
            String componentCode = reportComponent.getCode().getCodingFirstRep().getCode();
            String componentValue = reportComponent.getValue().getCodingFirstRep().getCode();

            boolean matchFound = stratumValues.stream().anyMatch(sv -> {
                String svCode = sv.def() != null && sv.def().code() != null
                        ? sv.def().code().text() : null;
                String svValue = sv.value() != null ? sv.value().getValueAsString() : null;
                return Objects.equals(componentCode, svCode) && Objects.equals(componentValue, svValue);
            });

            if (!matchFound) {
                return false;
            }
        }
        return true;
    }

    // Single value comparison - use string representation
    if (reportStratum.hasValue() && stratumValues.size() == 1) {
        var stratumValue = stratumValues.iterator().next();
        String reportValue = reportStratum.getValue().getCodingFirstRep().getCode();
        String defValue = stratumValue.value() != null ? stratumValue.value().getValueAsString() : null;
        return Objects.equals(reportValue, defValue);
    }

    return false;
}
```

**Files Modified:**
- `cqf-fhir-cr/.../r4/R4MeasureReportBuilder.java`
- `cqf-fhir-cr/src/test/java/.../r4/R4MeasureReportBuilderTest.java` (CREATE or enhance)

---

### Phase 4: DSTU3 Builder Score Copying Logic

**Objective:** Add score copying methods to Dstu3MeasureReportBuilder (mirrors R4 implementation).

**Tasks:**
1. Add `copyScoresFromDef(Measure, MeasureDef, MeasureReport)` method
2. Add `copyStratifierScores()` helper method
3. **Add** copyScoresFromDef() call **before** existing scorer call (line 98)
4. **Keep** existing measureReportScorer.score() call
5. Add unit tests for score copying logic

**Implementation:**

#### Dstu3MeasureReportBuilder.java
```java
@Override
public MeasureReport build(
        Measure measure,
        MeasureDef measureDef,
        MeasureReportType measureReportType,
        Interval measurementPeriod,
        List<String> subjectIds) {
    this.reset();

    this.measure = measure;
    this.report = this.createMeasureReport(measure, measureReportType, subjectIds, measurementPeriod);

    buildGroups(measure, measureDef);
    processSdes(measure, measureDef, subjectIds);

    // NEW: Copy scores from Def objects (Part 1: does nothing, null scores)
    copyScoresFromDef(measure, measureDef, this.report);

    // KEEP: Old scorer still produces scores (Part 1: source of truth)
    this.measureReportScorer.score(measure.getUrl(), measureDef, this.report);

    // Only add evaluated resources to individual reports
    if (measureReportType == MeasureReportType.INDIVIDUAL) {
        ListResource references = this.createReferenceList(
                "evaluated-resources-references",
                this.getEvaluatedResourceReferences().values());
        this.report.addContained(references);
        this.report.setEvaluatedResources(new Reference("#" + references.getId()));
    }

    return this.report;
}

/**
 * Copy scores from MeasureDef to MeasureReport.
 * Added in Part 1 (integrate-measure-def-scorer-part1-foundation).
 * In Part 1, this does nothing because Def objects have null scores.
 * In Part 2 (integrate-measure-def-scorer-part2-integration), this becomes active
 * when MeasureDefScorer is called in MeasureEvaluationResultHandler.
 *
 * Logic is driven by Def objects, matching report structures by ID.
 * Logs warnings when matching report structures are not found.
 *
 * @param measureDef the MeasureDef
 */
private void copyScoresFromDef(MeasureDef measureDef) {
    // Iterate through GroupDefs (drive from Def side)
    for (var groupDef : measureDef.groups()) {
        // Find matching report group by ID
        var reportGroup = this.report.getGroup().stream()
                .filter(rg -> groupDef.id().equals(rg.getId()))
                .findFirst()
                .orElse(null);

        if (reportGroup == null) {
            logger.warn("No matching MeasureReport group found for GroupDef with id: {}", groupDef.id());
            continue;
        }

        // Copy group-level score (DSTU3 uses setMeasureScore(Double) directly)
        Double groupScore = groupDef.getMeasureScore();
        if (groupScore != null) {
            reportGroup.setMeasureScore(groupScore);
        }

        // Copy stratifier scores
        copyStratifierScores(reportGroup, groupDef);
    }
}

/**
 * Copy stratifier scores from StratifierDef objects to DSTU3 MeasureReport stratifiers.
 * Logic is driven by StratifierDef objects, matching report stratifiers by ID.
 *
 * @param reportGroup the DSTU3 MeasureReport group component
 * @param groupDef the GroupDef containing stratifier scores
 */
private void copyStratifierScores(MeasureReportGroupComponent reportGroup, GroupDef groupDef) {
    // Iterate through StratifierDefs (drive from Def side)
    for (var stratifierDef : groupDef.stratifiers()) {
        // Find matching report stratifier by ID
        var reportStratifier = reportGroup.getStratifier().stream()
                .filter(rs -> stratifierDef.id().equals(rs.getId()))
                .findFirst()
                .orElse(null);

        if (reportStratifier == null) {
            logger.warn("No matching MeasureReport stratifier found for StratifierDef with id: {}",
                    stratifierDef.id());
            continue;
        }

        // Iterate through StratumDefs (drive from Def side)
        for (var stratumDef : stratifierDef.getStratum()) {
            // Find matching report stratum by comparing value strings
            var reportStratum = reportStratifier.getStratum().stream()
                    .filter(rs -> matchesStratumValue(rs, stratumDef))
                    .findFirst()
                    .orElse(null);

            if (reportStratum == null) {
                logger.debug("No matching MeasureReport stratum found for StratumDef in stratifier: {}",
                        stratifierDef.id());
                continue;
            }

            // Copy stratum score (DSTU3 uses setMeasureScore(Double) directly)
            Double stratumScore = stratumDef.getMeasureScore();
            if (stratumScore != null) {
                reportStratum.setMeasureScore(stratumScore);
            }
        }
    }
}

/**
 * Check if a DSTU3 MeasureReport stratum matches a StratumDef by comparing string representations.
 * DSTU3 uses StratifierGroupComponent (simpler than R4, no component stratifiers).
 *
 * @param reportStratum the DSTU3 MeasureReport stratum (StratifierGroupComponent)
 * @param stratumDef the StratumDef
 * @return true if values match
 */
private boolean matchesStratumValue(StratifierGroupComponent reportStratum, StratumDef stratumDef) {
    var stratumValues = stratumDef.valueDefs();

    // Single value comparison - DSTU3 doesn't have component stratifiers like R4
    if (reportStratum.hasValue() && stratumValues.size() == 1) {
        var stratumValue = stratumValues.iterator().next();
        String reportValue = reportStratum.getValue();
        String defValue = stratumValue.value() != null ? stratumValue.value().getValueAsString() : null;
        return Objects.equals(reportValue, defValue);
    }

    return false;
}
```

**Files Modified:**
- `cqf-fhir-cr/.../dstu3/Dstu3MeasureReportBuilder.java`
- `cqf-fhir-cr/src/test/java/.../dstu3/Dstu3MeasureReportBuilderTest.java` (CREATE or enhance)

---

### Phase 5: MeasureReportScoringFhirAdapter (cdr-cr API)

**Objective:** Create version-agnostic API for post-hoc scoring of MeasureReports (cdr-cr use case).

**Tasks:**
1. Create `MeasureReportScoringFhirAdapter` class with full implementation
2. Implement `score(IBaseResource measure, IBaseResource measureReport)` public API
3. Implement R4-specific helpers: `scoreR4()`, `populateMeasureDefFromR4Report()`, `copyScoresToR4Report()`
4. Implement DSTU3-specific helpers: `scoreDstu3()`, `populateMeasureDefFromDstu3Report()`, `copyScoresToDstu3Report()`
5. Add comprehensive Javadoc with cdr-cr usage examples
6. Add unit tests for adapter (R4, DSTU3, version detection, error cases)

**Implementation:**

```java
package org.opencds.cqf.fhir.cr.measure.common;

import ca.uhn.fhir.rest.server.exceptions.UnprocessableEntityException;
import org.hl7.fhir.instance.model.api.IBaseResource;
import org.opencds.cqf.fhir.api.FhirVersionEnum;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * Version-agnostic utility for post-hoc scoring of FHIR MeasureReports.
 *
 * <p>This adapter is designed for scenarios where a MeasureReport has already been
 * populated with population counts (e.g., from a database or external system) but
 * needs scores calculated. It automatically detects the FHIR version and applies
 * the appropriate scoring logic.
 *
 * <h3>Use Cases:</h3>
 * <ul>
 *   <li>Scoring MeasureReports retrieved from persistent storage (e.g., cdr-cr project)</li>
 *   <li>Re-scoring MeasureReports after data corrections</li>
 *   <li>Batch scoring operations on historical MeasureReports</li>
 * </ul>
 *
 * <h3>Example Usage (cdr-cr project):</h3>
 * <pre>{@code
 * // Before (version-specific):
 * public void scoreMeasureReport(Measure theMeasure, MeasureReport theMeasureReport) {
 *     R4MeasureDefBuilder measureDefBuilder = new R4MeasureDefBuilder();
 *     R4MeasureReportScorer scorer = new R4MeasureReportScorer();
 *     scorer.score(theMeasure.getUrl(), measureDefBuilder.build(theMeasure), theMeasureReport);
 * }
 *
 * // After (version-agnostic):
 * public void scoreMeasureReport(Measure theMeasure, MeasureReport theMeasureReport) {
 *     MeasureReportScoringFhirAdapter.score(theMeasure, theMeasureReport);
 * }
 * }</pre>
 *
 * <h3>Architecture:</h3>
 * <ol>
 *   <li>Detect FHIR version from Measure resource</li>
 *   <li>Build MeasureDef from Measure structure (version-specific)</li>
 *   <li>Extract population counts from MeasureReport into MeasureDef (version-specific)</li>
 *   <li>Call {@link MeasureDefScorer#score(String, MeasureDef)} (version-agnostic)</li>
 *   <li>Copy computed scores back to MeasureReport (version-specific)</li>
 * </ol>
 *
 * <p><strong>Thread Safety:</strong> This class is stateless and thread-safe.
 *
 * @see MeasureDefScorer
 * @see org.opencds.cqf.fhir.cr.measure.r4.R4MeasureReportScorer (deprecated)
 * @since 3.x.x
 */
public class MeasureReportScoringFhirAdapter {

    private static final Logger logger = LoggerFactory.getLogger(MeasureReportScoringFhirAdapter.class);

    private MeasureReportScoringFhirAdapter() {
        // Static utility class
    }

    /**
     * Score a MeasureReport that already has population counts populated.
     *
     * <p>This method automatically detects the FHIR version and applies the appropriate
     * scoring logic. The MeasureReport is mutated in place with computed scores.
     *
     * @param measure the Measure resource defining scoring logic and improvement notation
     * @param measureReport the MeasureReport to score (must have population counts already set)
     * @throws UnprocessableEntityException if FHIR version not supported or resources incompatible
     * @throws IllegalArgumentException if measure or measureReport is null
     */
    public static void score(IBaseResource measure, IBaseResource measureReport) {
        if (measure == null) {
            throw new IllegalArgumentException("Measure cannot be null");
        }
        if (measureReport == null) {
            throw new IllegalArgumentException("MeasureReport cannot be null");
        }

        // Auto-detect FHIR version from measure
        FhirVersionEnum measureVersion = FhirVersionEnum.forVersionString(
            measure.getStructureFhirVersionEnum().getFhirVersionString());
        FhirVersionEnum reportVersion = FhirVersionEnum.forVersionString(
            measureReport.getStructureFhirVersionEnum().getFhirVersionString());

        // Verify versions match
        if (measureVersion != reportVersion) {
            throw new UnprocessableEntityException(String.format(
                "Measure version (%s) does not match MeasureReport version (%s)",
                measureVersion, reportVersion));
        }

        logger.debug("Scoring MeasureReport using FHIR version: {}", measureVersion);

        // Delegate to version-specific implementation
        switch (measureVersion) {
            case R4:
                scoreR4(
                    (org.hl7.fhir.r4.model.Measure) measure,
                    (org.hl7.fhir.r4.model.MeasureReport) measureReport);
                break;
            case DSTU3:
                scoreDstu3(
                    (org.hl7.fhir.dstu3.model.Measure) measure,
                    (org.hl7.fhir.dstu3.model.MeasureReport) measureReport);
                break;
            case R5:
                throw new UnprocessableEntityException(
                    "R5 scoring not yet implemented. Please use R4 or DSTU3.");
            default:
                throw new UnprocessableEntityException(
                    "Unsupported FHIR version for measure scoring: " + measureVersion);
        }
    }

    /**
     * Score an R4 MeasureReport.
     */
    private static void scoreR4(
            org.hl7.fhir.r4.model.Measure measure,
            org.hl7.fhir.r4.model.MeasureReport measureReport) {

        // 1. Build MeasureDef from Measure structure
        var measureDefBuilder = new org.opencds.cqf.fhir.cr.measure.r4.R4MeasureDefBuilder();
        MeasureDef measureDef = measureDefBuilder.build(measure);

        // 2. Populate MeasureDef with population counts from MeasureReport
        populateMeasureDefFromR4Report(measureDef, measureReport);

        // 3. Score using version-agnostic scorer
        MeasureDefScorer scorer = new MeasureDefScorer();
        scorer.score(measure.getUrl(), measureDef);

        // 4. Copy computed scores back to MeasureReport
        copyScoresToR4Report(measureDef, measureReport);
    }

    /**
     * Populate MeasureDef with population counts from R4 MeasureReport.
     * This allows MeasureDefScorer to calculate scores based on existing counts.
     */
    private static void populateMeasureDefFromR4Report(
            MeasureDef measureDef,
            org.hl7.fhir.r4.model.MeasureReport measureReport) {

        var groups = measureDef.groups();
        var reportGroups = measureReport.getGroup();

        if (groups.size() != reportGroups.size()) {
            throw new UnprocessableEntityException(String.format(
                "MeasureDef group count (%d) does not match MeasureReport group count (%d)",
                groups.size(), reportGroups.size()));
        }

        for (int i = 0; i < groups.size(); i++) {
            GroupDef groupDef = groups.get(i);
            var reportGroup = reportGroups.get(i);

            // Populate population counts
            for (var reportPop : reportGroup.getPopulation()) {
                String popCode = reportPop.getCode().getCodingFirstRep().getCode();
                int count = reportPop.getCount();

                // Find matching PopulationDef and set count
                groupDef.populations().stream()
                    .filter(p -> p.populationType().toCode().equals(popCode))
                    .forEach(p -> p.setCount(count));
            }

            // Populate stratifier counts if present
            if (reportGroup.hasStratifier()) {
                populateStratifierCountsFromR4Report(groupDef, reportGroup);
            }
        }
    }

    /**
     * Populate stratifier counts from R4 MeasureReport.
     */
    private static void populateStratifierCountsFromR4Report(
            GroupDef groupDef,
            org.hl7.fhir.r4.model.MeasureReport.MeasureReportGroupComponent reportGroup) {

        // Note: This is a simplified version - full implementation would need to match
        // StratifierDefs with report stratifiers and populate StratumPopulationDefs
        // For now, we assume stratifiers are already populated or not needed for scoring
        logger.debug("Stratifier population not yet implemented for post-hoc scoring");
    }

    /**
     * Copy computed scores from MeasureDef to R4 MeasureReport.
     */
    private static void copyScoresToR4Report(
            MeasureDef measureDef,
            org.hl7.fhir.r4.model.MeasureReport measureReport) {

        var groups = measureDef.groups();
        var reportGroups = measureReport.getGroup();

        for (int i = 0; i < groups.size(); i++) {
            GroupDef groupDef = groups.get(i);
            var reportGroup = reportGroups.get(i);

            // Copy group-level score with improvement notation applied
            Double groupScore = groupDef.getMeasureScore();
            if (groupScore != null && groupScore >= 0) {
                reportGroup.setMeasureScore(new org.hl7.fhir.r4.model.Quantity(groupScore));
            }

            // Copy stratifier scores if present
            if (reportGroup.hasStratifier() && !groupDef.stratifiers().isEmpty()) {
                copyStratifierScoresToR4Report(groupDef, reportGroup);
            }
        }
    }

    /**
     * Copy stratifier scores from GroupDef to R4 MeasureReport.
     */
    private static void copyStratifierScoresToR4Report(
            GroupDef groupDef,
            org.hl7.fhir.r4.model.MeasureReport.MeasureReportGroupComponent reportGroup) {

        for (int stratIdx = 0; stratIdx < reportGroup.getStratifier().size(); stratIdx++) {
            var reportStratifier = reportGroup.getStratifier().get(stratIdx);

            // Find matching StratifierDef (by index for now)
            if (stratIdx >= groupDef.stratifiers().size()) {
                continue;
            }
            StratifierDef stratifierDef = groupDef.stratifiers().get(stratIdx);

            // Copy stratum scores
            for (int stratumIdx = 0; stratumIdx < reportStratifier.getStratum().size(); stratumIdx++) {
                var reportStratum = reportStratifier.getStratum().get(stratumIdx);

                if (stratumIdx >= stratifierDef.getStratum().size()) {
                    continue;
                }
                StratumDef stratumDef = stratifierDef.getStratum().get(stratumIdx);

                // Copy stratum score with improvement notation applied
                Double stratumScore = stratumDef.getMeasureScore();
                if (stratumScore != null && stratumScore >= 0) {
                    reportStratum.setMeasureScore(new org.hl7.fhir.r4.model.Quantity(stratumScore));
                }
            }
        }
    }

    /**
     * Score a DSTU3 MeasureReport.
     */
    private static void scoreDstu3(
            org.hl7.fhir.dstu3.model.Measure measure,
            org.hl7.fhir.dstu3.model.MeasureReport measureReport) {

        // 1. Build MeasureDef from Measure structure
        var measureDefBuilder = new org.opencds.cqf.fhir.cr.measure.dstu3.Dstu3MeasureDefBuilder();
        MeasureDef measureDef = measureDefBuilder.build(measure);

        // 2. Populate MeasureDef with population counts from MeasureReport
        populateMeasureDefFromDstu3Report(measureDef, measureReport);

        // 3. Score using version-agnostic scorer
        MeasureDefScorer scorer = new MeasureDefScorer();
        scorer.score(measure.getUrl(), measureDef);

        // 4. Copy computed scores back to MeasureReport
        copyScoresToDstu3Report(measureDef, measureReport);
    }

    /**
     * Populate MeasureDef with population counts from DSTU3 MeasureReport.
     */
    private static void populateMeasureDefFromDstu3Report(
            MeasureDef measureDef,
            org.hl7.fhir.dstu3.model.MeasureReport measureReport) {

        var groups = measureDef.groups();
        var reportGroups = measureReport.getGroup();

        if (groups.size() != reportGroups.size()) {
            throw new UnprocessableEntityException(String.format(
                "MeasureDef group count (%d) does not match MeasureReport group count (%d)",
                groups.size(), reportGroups.size()));
        }

        for (int i = 0; i < groups.size(); i++) {
            GroupDef groupDef = groups.get(i);
            var reportGroup = reportGroups.get(i);

            // Populate population counts
            for (var reportPop : reportGroup.getPopulation()) {
                String popCode = reportPop.getCode().getCodingFirstRep().getCode();
                int count = reportPop.getCount();

                // Find matching PopulationDef and set count
                groupDef.populations().stream()
                    .filter(p -> p.populationType().toCode().equals(popCode))
                    .forEach(p -> p.setCount(count));
            }

            // Populate stratifier counts if present
            if (reportGroup.hasStratifier()) {
                populateStratifierCountsFromDstu3Report(groupDef, reportGroup);
            }
        }
    }

    /**
     * Populate stratifier counts from DSTU3 MeasureReport.
     */
    private static void populateStratifierCountsFromDstu3Report(
            GroupDef groupDef,
            org.hl7.fhir.dstu3.model.MeasureReport.MeasureReportGroupComponent reportGroup) {

        logger.debug("Stratifier population not yet implemented for DSTU3 post-hoc scoring");
    }

    /**
     * Copy computed scores from MeasureDef to DSTU3 MeasureReport.
     */
    private static void copyScoresToDstu3Report(
            MeasureDef measureDef,
            org.hl7.fhir.dstu3.model.MeasureReport measureReport) {

        var groups = measureDef.groups();
        var reportGroups = measureReport.getGroup();

        for (int i = 0; i < groups.size(); i++) {
            GroupDef groupDef = groups.get(i);
            var reportGroup = reportGroups.get(i);

            // Copy group-level score with improvement notation applied
            Double groupScore = groupDef.getMeasureScore();
            if (groupScore != null && groupScore >= 0) {
                reportGroup.setMeasureScore(new org.hl7.fhir.dstu3.model.Quantity(groupScore));
            }

            // Copy stratifier scores if present
            if (reportGroup.hasStratifier() && !groupDef.stratifiers().isEmpty()) {
                copyStratifierScoresToDstu3Report(groupDef, reportGroup);
            }
        }
    }

    /**
     * Copy stratifier scores from GroupDef to DSTU3 MeasureReport.
     */
    private static void copyStratifierScoresToDstu3Report(
            GroupDef groupDef,
            org.hl7.fhir.dstu3.model.MeasureReport.MeasureReportGroupComponent reportGroup) {

        for (int stratIdx = 0; stratIdx < reportGroup.getStratifier().size(); stratIdx++) {
            var reportStratifier = reportGroup.getStratifier().get(stratIdx);

            if (stratIdx >= groupDef.stratifiers().size()) {
                continue;
            }
            StratifierDef stratifierDef = groupDef.stratifiers().get(stratIdx);

            // Copy stratum scores - DSTU3 uses .setValue() instead of .setMeasureScore()
            for (int stratumIdx = 0; stratumIdx < reportStratifier.getStratum().size(); stratumIdx++) {
                var reportStratum = reportStratifier.getStratum().get(stratumIdx);

                if (stratumIdx >= stratifierDef.getStratum().size()) {
                    continue;
                }
                StratumDef stratumDef = stratifierDef.getStratum().get(stratumIdx);

                // Copy stratum score with improvement notation applied
                Double stratumScore = stratumDef.getMeasureScore();
                if (stratumScore != null && stratumScore >= 0) {
                    reportStratum.setValue(new org.hl7.fhir.dstu3.model.Quantity(stratumScore));
                }
            }
        }
    }
}
```

**Key Points:**
- This is the **only** place in Part 1 where old scorers are bypassed
- Uses MeasureDefScorer directly for scoring
- Supports R4 and DSTU3 (R5 throws "not yet implemented")
- Automatic FHIR version detection
- Comprehensive error handling

**Files Created:**
- `cqf-fhir-cr/.../common/MeasureReportScoringFhirAdapter.java`
- `cqf-fhir-cr/src/test/java/.../common/MeasureReportScoringFhirAdapterTest.java`

---

### Phase 6: Deprecation

**Objective:** Mark old scorers for future removal while keeping them fully functional.

**Tasks:**
1. Add `@Deprecated` annotation to `R4MeasureReportScorer`
2. Add `@Deprecated` annotation to `Dstu3MeasureReportScorer`
3. Add `@Deprecated` annotation to `IMeasureReportScorer`
4. Add `@Deprecated` annotation to `BaseMeasureReportScorer`
5. Add Javadoc with migration guidance pointing to `MeasureReportScoringFhirAdapter`

**Implementation:**

#### R4MeasureReportScorer.java
```java
/**
 * Evaluation of Measure Report Data showing raw CQL criteria results compared to resulting Measure Report.
 *
 * @deprecated This class is deprecated and will be removed in a future release.
 *             For external consumers (e.g., cdr-cr project), use
 *             {@link MeasureReportScoringFhirAdapter#score(IBaseResource, IBaseResource)}
 *             for version-agnostic post-hoc scoring.
 *             For internal use, this class will be replaced by {@link MeasureDefScorer}
 *             integrated into the evaluation workflow in Part 2.
 *             See: integrate-measure-def-scorer-part2-integration.md
 */
@Deprecated(since = "3.x.x", forRemoval = true)
@SuppressWarnings("squid:S1135")
public class R4MeasureReportScorer extends BaseMeasureReportScorer<MeasureReport> {
    // ... existing implementation unchanged ...
}
```

#### Similar deprecation for:
- `Dstu3MeasureReportScorer.java`
- `IMeasureReportScorer.java`
- `BaseMeasureReportScorer.java`

**Files Modified:**
- `cqf-fhir-cr/.../r4/R4MeasureReportScorer.java`
- `cqf-fhir-cr/.../dstu3/Dstu3MeasureReportScorer.java`
- `cqf-fhir-cr/.../common/IMeasureReportScorer.java`
- `cqf-fhir-cr/.../common/BaseMeasureReportScorer.java`

---

### Phase 7: Testing and Validation

**Objective:** Comprehensive unit testing of all new components.

**Tasks:**
1. Run all existing Measure/MultiMeasure tests - verify no regressions
2. Add unit tests for RatioMeasureObservationCache construction
3. Add unit tests for StratumDef.getMeasureScore()
4. Add unit tests for COHORT scoring (returns null)
5. Add unit tests for COMPOSITE scoring (returns null)
6. Add unit tests for R4 builder score copying (7 tests)
7. Add unit tests for DSTU3 builder score copying (7 tests)
8. Add comprehensive unit tests for MeasureReportScoringFhirAdapter (19+ tests)

**Test Coverage:**

#### R4MeasureReportBuilderTest
```java
@Test
void testCopyScoresFromDef_GroupScores_NullInPart1() {
    // Given: MeasureDef with null scores (Part 1: MeasureDefScorer not called)
    MeasureDef measureDef = createMeasureDefWithoutScores();

    // When: Build R4 MeasureReport
    MeasureReport report = builder.build(...);

    // Then: Group scores NOT copied (null check passes)
    assertNull(report.getGroup().get(0).getMeasureScore());
    // Note: Old scorer will fill in scores after copyScoresFromDef()
}

@Test
void testCopyScoresFromDef_GroupScores_PopulatedWhenAvailable() {
    // Given: MeasureDef with scores set (simulating Part 2)
    MeasureDef measureDef = createMeasureDefWithScores();
    measureDef.groups().get(0).setScore(0.75);

    // When: copyScoresFromDef is called directly
    copyScoresFromDef(bc);

    // Then: Group scores copied correctly
    assertEquals(0.75, report.getGroup().get(0).getMeasureScore().getValue().doubleValue());
}

// Additional 5 tests: stratifier scores, improvement notation, null handling, negative scores, multiple groups
```

#### MeasureReportScoringFhirAdapterTest
- 8 R4 tests (proportion, ratio, cohort, stratifiers, improvement notation, multiple groups, zero denominator)
- 5 DSTU3 tests (proportion, ratio, cohort, stratifiers, improvement notation)
- 4 version detection tests (R4 auto-detect, DSTU3 auto-detect, mismatch error, R5 not implemented)
- 3 error handling tests (null measure, null report, group count mismatch)
- 1 integration test (real-world cdr-cr usage)

**Files Modified/Created:**
- `cqf-fhir-cr/src/test/java/.../common/MeasureDefScorerTest.java` (enhance)
- `cqf-fhir-cr/src/test/java/.../r4/R4MeasureReportBuilderTest.java` (CREATE or enhance)
- `cqf-fhir-cr/src/test/java/.../dstu3/Dstu3MeasureReportBuilderTest.java` (CREATE or enhance)
- `cqf-fhir-cr/src/test/java/.../common/MeasureReportScoringFhirAdapterTest.java` (CREATE)

---

## Files Summary

### Files Created (Part 1)
- `cqf-fhir-cr/.../common/RatioMeasureObservationCache.java`
- `cqf-fhir-cr/.../common/MeasureReportScoringFhirAdapter.java`
- `cqf-fhir-cr/src/test/java/.../common/MeasureReportScoringFhirAdapterTest.java`
- `cqf-fhir-cr/src/test/java/.../r4/R4MeasureReportBuilderTest.java` (if doesn't exist)
- `cqf-fhir-cr/src/test/java/.../dstu3/Dstu3MeasureReportBuilderTest.java` (if doesn't exist)

### Files Modified (Part 1)
- `cqf-fhir-cr/.../common/StratumDef.java`
- `cqf-fhir-cr/.../common/GroupDef.java` (findRatioObservationPopulationDef - already exists)
- `cqf-fhir-cr/.../common/MeasureDefScorer.java`
- `cqf-fhir-cr/.../common/MeasureMultiSubjectEvaluator.java`
- `cqf-fhir-cr/.../r4/R4MeasureReportBuilder.java`
- `cqf-fhir-cr/.../dstu3/Dstu3MeasureReportBuilder.java`
- `cqf-fhir-cr/.../r4/R4MeasureReportScorer.java` (@Deprecated)
- `cqf-fhir-cr/.../dstu3/Dstu3MeasureReportScorer.java` (@Deprecated)
- `cqf-fhir-cr/.../common/IMeasureReportScorer.java` (@Deprecated)
- `cqf-fhir-cr/.../common/BaseMeasureReportScorer.java` (@Deprecated)
- Test files (update StratumDef constructor calls with groupDef parameter)

### Files NOT Modified (Part 1)
- `cqf-fhir-cr/.../common/MeasureEvaluationResultHandler.java` (Part 2)

---

## Success Criteria (Part 1)

### Functional Requirements
- ✅ All existing tests pass (no regressions)
- ✅ Scores identical to baseline (old scorers produce scores)
- ✅ copyScoresFromDef() does nothing (null scores in Def objects)
- ✅ MeasureReportScoringFhirAdapter works for cdr-cr use case
- ✅ RatioMeasureObservationCache improves performance (~36% reduction)
- ✅ COHORT measures return null scores
- ✅ COMPOSITE measures return null scores

### Non-Functional Requirements
- ✅ Version-agnostic API ready for external use
- ✅ Clear deprecation path documented
- ✅ Zero behavior change for regular measure evaluation
- ✅ Performance maintained or improved
- ✅ Comprehensive unit test coverage (30+ new tests)

### Code Quality
- ✅ JavaDoc on all new classes/methods
- ✅ Consistent naming conventions
- ✅ Proper null handling
- ✅ Code formatted with spotless

---

## Testing Strategy

### Test Phases
1. **Unit Tests** - All new components tested in isolation
2. **Integration Tests** - Run full existing test suite
3. **Regression Tests** - Compare scores before/after
4. **Performance Tests** - Verify observation caching optimization

### Expected Results
- All existing tests pass unchanged
- New unit tests pass
- Scores match baseline exactly (old scorers still active)
- No performance regression
- MeasureReportScoringFhirAdapter ready for cdr-cr

---

## Risk Mitigation

### Risk 1: Accidental Behavior Change
**Likelihood:** Low
**Impact:** High
**Mitigation:**
- copyScoresFromDef() has null checks (does nothing with null scores)
- Old scorers remain active and produce scores
- Full regression test suite run before merge

### Risk 2: Performance Regression
**Likelihood:** Very Low
**Impact:** Medium
**Mitigation:**
- RatioMeasureObservationCache improves performance
- No additional computation in critical path (old scorers unchanged)
- Performance tests verify no regression

### Risk 3: Test Failures
**Likelihood:** Low
**Impact:** Low
**Mitigation:**
- Comprehensive unit tests catch issues early
- Iterative fix-and-test approach
- Test coverage for edge cases

---

## Part 2 Dependency

**What Part 2 Needs from Part 1:**
- ✅ copyScoresFromDef() methods in R4/DSTU3 builders (ready to activate)
- ✅ MeasureDefScorer with COHORT/COMPOSITE support
- ✅ StratumDef.getMeasureScore() method
- ✅ RatioMeasureObservationCache for performance
- ✅ Deprecated old scorers (ready for removal)

**What Part 2 Will Do:**
- Add MeasureDefScorer call in MeasureEvaluationResultHandler (activates score population)
- Remove old scorer calls from builders (copyScoresFromDef becomes sole path)
- Add Fhir2Def integration tests
- Iteratively fix any gaps in MeasureDefScorer

---

## Conclusion

Part 1 establishes a safe, tested foundation for version-agnostic measure scoring:
- **Zero risk** - No behavior change for existing workflows
- **Immediate value** - MeasureReportScoringFhirAdapter ready for cdr-cr
- **Performance improved** - RatioMeasureObservationCache optimization
- **Well tested** - 30+ new unit tests
- **Clear path forward** - Part 2 ready to activate new scoring

**Ready for Part 2:** integrate-measure-def-scorer-part2-integration.md
