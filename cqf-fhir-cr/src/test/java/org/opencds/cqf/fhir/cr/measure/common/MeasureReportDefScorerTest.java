package org.opencds.cqf.fhir.cr.measure.common;

import static org.junit.jupiter.api.Assertions.*;

import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import org.junit.jupiter.api.Test;
import org.opencds.cqf.fhir.cr.measure.MeasureStratifierType;

/**
 * Comprehensive unit tests for version-agnostic MeasureReportDefScorer.
 *
 * Tests the Def-first iteration pattern AND mutation-based design where
 * scores are set directly on Def objects using setScore() methods.
 *
 * All tests use constructors to create Def objects (NO MOCKS).
 *
 * Generated by Claude Sonnet 4.5 on 2025-12-03
 */
class MeasureReportDefScorerTest {

    private final MeasureReportDefScorer scorer = new MeasureReportDefScorer();

    @Test
    void testScoreGroup_SetsScoreOnGroupDef() {
        // Setup: Simple proportion measure with 3/4 subjects meeting criteria
        CodeDef encounterBasis = createPopulationBasisCode("Encounter");
        PopulationDef numeratorPop = createPopulationDef(
                "num-1", MeasurePopulationType.NUMERATOR, Set.of("patient1", "patient2", "patient3"), encounterBasis);
        PopulationDef denominatorPop = createPopulationDef(
                "den-1",
                MeasurePopulationType.DENOMINATOR,
                Set.of("patient1", "patient2", "patient3", "patient4"),
                encounterBasis);

        GroupDef groupDef = new GroupDef(
                "group-1",
                createTextOnlyConcept("Test Group"),
                List.of(), // No stratifiers
                List.of(numeratorPop, denominatorPop),
                MeasureScoring.PROPORTION,
                false,
                createImprovementNotationCode("increase"),
                encounterBasis);

        // Score is null before scoring
        assertNull(groupDef.getScore());

        scorer.scoreGroup("http://example.com/Measure/test", groupDef);

        // VERIFY: aggregationResult is null for all populations (PROPORTION measure)
        assertNull(numeratorPop.getAggregationResult());
        assertNull(denominatorPop.getAggregationResult());

        // VERIFY: Score is set on GroupDef via mutation
        assertEquals(0.75, groupDef.getScore(), 0.001);
    }

    @Test
    void testScoreGroup_ProportionWithExclusions() {
        // Setup: Proportion measure with exclusions and exceptions
        // Formula: (n - nx) / (d - dx - de)
        // (10 - 2) / (20 - 3 - 1) = 8 / 16 = 0.5
        CodeDef stringBasis = createPopulationBasisCode("String");
        PopulationDef numeratorPop = createPopulationDef(
                "num-1",
                MeasurePopulationType.NUMERATOR,
                Set.of("p1", "p2", "p3", "p4", "p5", "p6", "p7", "p8", "p9", "p10"),
                stringBasis);
        PopulationDef denominatorPop = createPopulationDef(
                "den-1",
                MeasurePopulationType.DENOMINATOR,
                Set.of(
                        "p1", "p2", "p3", "p4", "p5", "p6", "p7", "p8", "p9", "p10", "p11", "p12", "p13", "p14", "p15",
                        "p16", "p17", "p18", "p19", "p20"),
                stringBasis);
        PopulationDef denExclusionPop = createPopulationDef(
                "dex-1", MeasurePopulationType.DENOMINATOREXCLUSION, Set.of("p11", "p12", "p13"), stringBasis);
        PopulationDef denExceptionPop =
                createPopulationDef("dexc-1", MeasurePopulationType.DENOMINATOREXCEPTION, Set.of("p14"), stringBasis);
        PopulationDef numExclusionPop =
                createPopulationDef("nex-1", MeasurePopulationType.NUMERATOREXCLUSION, Set.of("p1", "p2"), stringBasis);

        GroupDef groupDef = new GroupDef(
                "group-1",
                createTextOnlyConcept("Test Group"),
                List.of(),
                List.of(numeratorPop, denominatorPop, denExclusionPop, denExceptionPop, numExclusionPop),
                MeasureScoring.PROPORTION,
                false,
                createImprovementNotationCode("increase"),
                stringBasis);

        scorer.scoreGroup("http://example.com/Measure/test", groupDef);

        // VERIFY: aggregationResult is null for all populations (PROPORTION measure)
        assertNull(numeratorPop.getAggregationResult());
        assertNull(denominatorPop.getAggregationResult());
        assertNull(denExclusionPop.getAggregationResult());
        assertNull(denExceptionPop.getAggregationResult());
        assertNull(numExclusionPop.getAggregationResult());

        // VERIFY: Score is set correctly
        assertEquals(0.5, groupDef.getScore(), 0.001);
    }

    @Test
    void testScoreGroup_ZeroDenominator_SetsNullScore() {
        // Setup: All subjects excluded from denominator
        CodeDef dateBasis = createPopulationBasisCode("date");
        PopulationDef numeratorPop = createPopulationDef(
                "num-1", MeasurePopulationType.NUMERATOR, Set.of("p1", "p2", "p3", "p4", "p5"), dateBasis);
        PopulationDef denominatorPop = createPopulationDef(
                "den-1",
                MeasurePopulationType.DENOMINATOR,
                Set.of("p1", "p2", "p3", "p4", "p5", "p6", "p7", "p8", "p9", "p10"),
                dateBasis);
        PopulationDef denExclusionPop = createPopulationDef(
                "dex-1",
                MeasurePopulationType.DENOMINATOREXCLUSION,
                Set.of("p1", "p2", "p3", "p4", "p5", "p6", "p7", "p8", "p9", "p10"),
                dateBasis); // All excluded

        GroupDef groupDef = new GroupDef(
                "group-1",
                createTextOnlyConcept("Test Group"),
                List.of(),
                List.of(numeratorPop, denominatorPop, denExclusionPop),
                MeasureScoring.PROPORTION,
                false,
                createImprovementNotationCode("increase"),
                dateBasis);

        scorer.scoreGroup("http://example.com/Measure/test", groupDef);

        // VERIFY: aggregationResult is null for all populations (PROPORTION measure)
        assertNull(numeratorPop.getAggregationResult());
        assertNull(denominatorPop.getAggregationResult());
        assertNull(denExclusionPop.getAggregationResult());

        // VERIFY: Null score set for zero denominator
        assertNull(groupDef.getScore());
    }

    @Test
    void testScoreStratifier_SetsScoresOnStratumDefs() {
        // Setup: Group with stratifier containing two strata
        // Male stratum: 3/5 = 0.6
        // Female stratum: 5/5 = 1.0

        CodeDef booleanBasisCode = createPopulationBasisCode("boolean");
        PopulationDef numeratorPop = createPopulationDef(
                "num-1",
                MeasurePopulationType.NUMERATOR,
                Set.of("male1", "male2", "male3", "female1", "female2", "female3", "female4", "female5"),
                booleanBasisCode);
        PopulationDef denominatorPop = createPopulationDef(
                "den-1",
                MeasurePopulationType.DENOMINATOR,
                Set.of(
                        "male1", "male2", "male3", "male4", "male5", "female1", "female2", "female3", "female4",
                        "female5"),
                booleanBasisCode);

        // Create stratum populations for Male stratum

        StratumPopulationDef maleNumPop = new StratumPopulationDef(
                numeratorPop,
                Set.of("male1", "male2", "male3"),
                Set.of(),
                List.of(),
                MeasureStratifierType.VALUE,
                booleanBasisCode);
        StratumPopulationDef maleDenPop = new StratumPopulationDef(
                denominatorPop,
                Set.of("male1", "male2", "male3", "male4", "male5"),
                Set.of(),
                List.of(),
                MeasureStratifierType.VALUE,
                booleanBasisCode);

        StratifierComponentDef genderComponent =
                new StratifierComponentDef("gender-component", createTextOnlyConcept("Gender"), "Gender");
        StratumDef maleStratum = new StratumDef(
                List.of(maleNumPop, maleDenPop),
                Set.of(new StratumValueDef(new StratumValueWrapper("male"), genderComponent)),
                Set.of("male1", "male2", "male3", "male4", "male5"),
                null);

        // Create stratum populations for Female stratum
        StratumPopulationDef femaleNumPop = new StratumPopulationDef(
                numeratorPop,
                Set.of("female1", "female2", "female3", "female4", "female5"),
                Set.of(),
                List.of(),
                MeasureStratifierType.VALUE,
                booleanBasisCode);
        StratumPopulationDef femaleDenPop = new StratumPopulationDef(
                denominatorPop,
                Set.of("female1", "female2", "female3", "female4", "female5"),
                Set.of(),
                List.of(),
                MeasureStratifierType.VALUE,
                booleanBasisCode);

        StratumDef femaleStratum = new StratumDef(
                List.of(femaleNumPop, femaleDenPop),
                Set.of(new StratumValueDef(new StratumValueWrapper("female"), genderComponent)),
                Set.of("female1", "female2", "female3", "female4", "female5"),
                null);

        StratifierDef stratifierDef = new StratifierDef(
                "gender-stratifier", createTextOnlyConcept("Gender Stratifier"), "Gender", MeasureStratifierType.VALUE);
        stratifierDef.addAllStratum(List.of(maleStratum, femaleStratum));

        GroupDef groupDef = new GroupDef(
                "group-1",
                createTextOnlyConcept("Test Group"),
                List.of(stratifierDef),
                List.of(numeratorPop, denominatorPop),
                MeasureScoring.PROPORTION,
                false,
                createImprovementNotationCode("increase"),
                booleanBasisCode);

        // Scores are null before scoring
        assertNull(maleStratum.getScore());
        assertNull(femaleStratum.getScore());

        // Execute
        scorer.scoreGroup("http://example.com/Measure/test", groupDef);

        // VERIFY: aggregationResult is null for all populations (PROPORTION measure)
        assertNull(numeratorPop.getAggregationResult());
        assertNull(denominatorPop.getAggregationResult());

        // VERIFY: Scores are set on each StratumDef via mutation
        assertEquals(0.6, maleStratum.getScore(), 0.001); // Male: 3/5
        assertEquals(1.0, femaleStratum.getScore(), 0.001); // Female: 5/5
    }

    @Test
    void testScoreGroup_RatioMeasure() {
        // Setup: Ratio measure with 6/12 = 0.5
        CodeDef stringBasis = createPopulationBasisCode("String");
        PopulationDef numeratorPop = createPopulationDef(
                "num-1", MeasurePopulationType.NUMERATOR, Set.of("p1", "p2", "p3", "p4", "p5", "p6"), stringBasis);
        PopulationDef denominatorPop = createPopulationDef(
                "den-1",
                MeasurePopulationType.DENOMINATOR,
                Set.of("p1", "p2", "p3", "p4", "p5", "p6", "p7", "p8", "p9", "p10", "p11", "p12"),
                stringBasis);

        GroupDef groupDef = new GroupDef(
                "group-1",
                createTextOnlyConcept("Test Group"),
                List.of(),
                List.of(numeratorPop, denominatorPop),
                MeasureScoring.RATIO,
                false,
                createImprovementNotationCode("increase"),
                stringBasis);

        assertNull(groupDef.getScore());

        scorer.scoreGroup("http://example.com/Measure/test", groupDef);

        // VERIFY: aggregationResult is null (basic RATIO without MEASUREOBSERVATION)
        assertNull(numeratorPop.getAggregationResult());
        assertNull(denominatorPop.getAggregationResult());

        assertEquals(0.5, groupDef.getScore(), 0.001);
    }

    @Test
    void testScoreGroup_ContinuousVariable_SumAggregation() {
        // Setup: Continuous variable measure with SUM aggregation
        // Subject observations: 10.0, 20.0, 30.0 = 60.0 total
        CodeDef dateBasis = createPopulationBasisCode("date");
        PopulationDef initialPopulation = createPopulationDef(
                "ip-1", MeasurePopulationType.INITIALPOPULATION, Set.of("p1", "p2", "p3"), dateBasis);

        PopulationDef measurePopulation = createPopulationDef(
                "mp-1", MeasurePopulationType.MEASUREPOPULATION, Set.of("p1", "p2", "p3"), dateBasis);

        // Create MEASUREOBSERVATION population with QuantityDef observations
        // Default aggregation method is SUM when not specified
        ConceptDef measureObsCode = createMeasurePopulationConcept(MeasurePopulationType.MEASUREOBSERVATION);
        PopulationDef measureObsPop = new PopulationDef(
                "msrobs-1",
                measureObsCode,
                MeasurePopulationType.MEASUREOBSERVATION,
                "expression",
                dateBasis,
                null,
                ContinuousVariableObservationAggregateMethod.SUM,
                null);

        // Add QuantityDef observations for each subject
        Map<String, QuantityDef> obs1 = new HashMap<>();
        obs1.put("obs-1", new QuantityDef(10.0));
        measureObsPop.addResource("p1", obs1);

        Map<String, QuantityDef> obs2 = new HashMap<>();
        obs2.put("obs-2", new QuantityDef(20.0));
        measureObsPop.addResource("p2", obs2);

        Map<String, QuantityDef> obs3 = new HashMap<>();
        obs3.put("obs-3", new QuantityDef(30.0));
        measureObsPop.addResource("p3", obs3);

        GroupDef groupDef = new GroupDef(
                "group-1",
                createTextOnlyConcept("Test Group"),
                List.of(),
                List.of(initialPopulation, measurePopulation, measureObsPop),
                MeasureScoring.CONTINUOUSVARIABLE,
                false,
                createImprovementNotationCode("increase"),
                dateBasis);

        assertNull(groupDef.getScore());

        scorer.scoreGroup("http://example.com/Measure/test", groupDef);

        // VERIFY: aggregationResult is null for non-observation populations
        assertNull(initialPopulation.getAggregationResult());
        assertNull(measurePopulation.getAggregationResult());

        // VERIFY: aggregationResult IS set for MEASUREOBSERVATION population (stores SUM result)
        assertNotNull(measureObsPop.getAggregationResult());
        assertEquals(60.0, measureObsPop.getAggregationResult(), 0.001);

        // VERIFY: SUM aggregation = 60.0
        assertEquals(60.0, groupDef.getScore(), 0.001);
    }

    @Test
    void testScoreGroup_ContinuousVariable_AvgAggregation() {
        // Setup: Continuous variable measure with AVG aggregation
        // Subject observations: 10.0, 20.0, 30.0 = 20.0 average
        CodeDef booleanBasis = createBooleanBasisCode();
        PopulationDef initialPopulation = createPopulationDef(
                "ip-1", MeasurePopulationType.INITIALPOPULATION, Set.of("p1", "p2", "p3"), booleanBasis);

        PopulationDef measurePopulation = createPopulationDef(
                "mp-1", MeasurePopulationType.MEASUREPOPULATION, Set.of("p1", "p2", "p3"), booleanBasis);

        ConceptDef measureObsCode = createMeasurePopulationConcept(MeasurePopulationType.MEASUREOBSERVATION);
        PopulationDef measureObsPop = new PopulationDef(
                "msrobs-1",
                measureObsCode,
                MeasurePopulationType.MEASUREOBSERVATION,
                "expression",
                booleanBasis,
                null,
                ContinuousVariableObservationAggregateMethod.AVG,
                null);

        Map<String, QuantityDef> obs1 = new HashMap<>();
        obs1.put("obs-1", new QuantityDef(10.0));
        measureObsPop.addResource("p1", obs1);

        Map<String, QuantityDef> obs2 = new HashMap<>();
        obs2.put("obs-2", new QuantityDef(20.0));
        measureObsPop.addResource("p2", obs2);

        Map<String, QuantityDef> obs3 = new HashMap<>();
        obs3.put("obs-3", new QuantityDef(30.0));
        measureObsPop.addResource("p3", obs3);

        GroupDef groupDef = new GroupDef(
                "group-1",
                createTextOnlyConcept("Test Group"),
                List.of(),
                List.of(initialPopulation, measurePopulation, measureObsPop),
                MeasureScoring.CONTINUOUSVARIABLE,
                false,
                createImprovementNotationCode("increase"),
                booleanBasis);

        assertNull(groupDef.getScore());

        scorer.scoreGroup("http://example.com/Measure/test", groupDef);

        // VERIFY: aggregationResult is null for non-observation populations
        assertNull(initialPopulation.getAggregationResult());
        assertNull(measurePopulation.getAggregationResult());

        // VERIFY: aggregationResult IS set for MEASUREOBSERVATION population (stores AVG result)
        assertNotNull(measureObsPop.getAggregationResult());
        assertEquals(20.0, measureObsPop.getAggregationResult(), 0.001);

        // VERIFY: AVG aggregation = 20.0
        assertEquals(20.0, groupDef.getScore(), 0.001);
    }

    @Test
    void testScoreGroup_ContinuousVariable_MinAggregation() {
        // Setup: Continuous variable with MIN aggregation
        // Subject observations: 10.0, 20.0, 30.0 = 10.0 min
        CodeDef encounterBasis = createPopulationBasisCode("Encounter");
        PopulationDef initialPopulation = createPopulationDef(
                "ip-1", MeasurePopulationType.INITIALPOPULATION, Set.of("p1", "p2", "p3"), encounterBasis);

        PopulationDef measurePopulation = createPopulationDef(
                "mp-1", MeasurePopulationType.MEASUREPOPULATION, Set.of("p1", "p2", "p3"), encounterBasis);

        ConceptDef measureObsCode = createMeasurePopulationConcept(MeasurePopulationType.MEASUREOBSERVATION);
        PopulationDef measureObsPop = new PopulationDef(
                "msrobs-1",
                measureObsCode,
                MeasurePopulationType.MEASUREOBSERVATION,
                "expression",
                encounterBasis,
                null,
                ContinuousVariableObservationAggregateMethod.MIN,
                null);

        Map<String, QuantityDef> obs1 = new HashMap<>();
        obs1.put("obs-1", new QuantityDef(10.0));
        measureObsPop.addResource("p1", obs1);

        Map<String, QuantityDef> obs2 = new HashMap<>();
        obs2.put("obs-2", new QuantityDef(20.0));
        measureObsPop.addResource("p2", obs2);

        Map<String, QuantityDef> obs3 = new HashMap<>();
        obs3.put("obs-3", new QuantityDef(30.0));
        measureObsPop.addResource("p3", obs3);

        GroupDef groupDef = new GroupDef(
                "group-1",
                createTextOnlyConcept("Test Group"),
                List.of(),
                List.of(initialPopulation, measurePopulation, measureObsPop),
                MeasureScoring.CONTINUOUSVARIABLE,
                false,
                createImprovementNotationCode("increase"),
                encounterBasis);

        assertNull(groupDef.getScore());

        scorer.scoreGroup("http://example.com/Measure/test", groupDef);

        // VERIFY: aggregationResult is null for non-observation populations
        assertNull(initialPopulation.getAggregationResult());
        assertNull(measurePopulation.getAggregationResult());

        // VERIFY: aggregationResult IS set for MEASUREOBSERVATION population (stores MIN result)
        assertNotNull(measureObsPop.getAggregationResult());
        assertEquals(10.0, measureObsPop.getAggregationResult(), 0.001);

        // VERIFY: MIN aggregation = 10.0
        assertEquals(10.0, groupDef.getScore(), 0.001);
    }

    @Test
    void testScoreGroup_ContinuousVariable_MaxAggregation() {
        // Setup: Continuous variable with MAX aggregation
        // Subject observations: 10.0, 20.0, 30.0 = 30.0 max
        CodeDef stringBasis = createPopulationBasisCode("String");
        PopulationDef initialPopulation = createPopulationDef(
                "ip-1", MeasurePopulationType.INITIALPOPULATION, Set.of("p1", "p2", "p3"), stringBasis);

        PopulationDef measurePopulation = createPopulationDef(
                "mp-1", MeasurePopulationType.MEASUREPOPULATION, Set.of("p1", "p2", "p3"), stringBasis);

        ConceptDef measureObsCode = createMeasurePopulationConcept(MeasurePopulationType.MEASUREOBSERVATION);
        PopulationDef measureObsPop = new PopulationDef(
                "msrobs-1",
                measureObsCode,
                MeasurePopulationType.MEASUREOBSERVATION,
                "expression",
                stringBasis,
                null,
                ContinuousVariableObservationAggregateMethod.MAX,
                null);

        Map<String, QuantityDef> obs1 = new HashMap<>();
        obs1.put("obs-1", new QuantityDef(10.0));
        measureObsPop.addResource("p1", obs1);

        Map<String, QuantityDef> obs2 = new HashMap<>();
        obs2.put("obs-2", new QuantityDef(20.0));
        measureObsPop.addResource("p2", obs2);

        Map<String, QuantityDef> obs3 = new HashMap<>();
        obs3.put("obs-3", new QuantityDef(30.0));
        measureObsPop.addResource("p3", obs3);

        GroupDef groupDef = new GroupDef(
                "group-1",
                createTextOnlyConcept("Test Group"),
                List.of(),
                List.of(initialPopulation, measurePopulation, measureObsPop),
                MeasureScoring.CONTINUOUSVARIABLE,
                false,
                createImprovementNotationCode("increase"),
                stringBasis);

        assertNull(groupDef.getScore());

        scorer.scoreGroup("http://example.com/Measure/test", groupDef);

        // VERIFY: aggregationResult is null for non-observation populations
        assertNull(initialPopulation.getAggregationResult());
        assertNull(measurePopulation.getAggregationResult());

        // VERIFY: aggregationResult IS set for MEASUREOBSERVATION population (stores MAX result)
        assertNotNull(measureObsPop.getAggregationResult());
        assertEquals(30.0, measureObsPop.getAggregationResult(), 0.001);

        // VERIFY: MAX aggregation = 30.0
        assertEquals(30.0, groupDef.getScore(), 0.001);
    }

    // ============================================================================
    // GroupDef.getMeasureScore() Tests - Improvement Notation Adjustment
    // ============================================================================

    @Test
    void testGetMeasureScore_NullScore() {
        // Setup: Group with no scoring performed (score is null)
        CodeDef dateBasis = createPopulationBasisCode("date");
        PopulationDef numeratorPop = createPopulationDef(
                "num-1", MeasurePopulationType.NUMERATOR, Set.of("patient1", "patient2", "patient3"), dateBasis);
        PopulationDef denominatorPop = createPopulationDef(
                "den-1",
                MeasurePopulationType.DENOMINATOR,
                Set.of("patient1", "patient2", "patient3", "patient4"),
                dateBasis);

        GroupDef groupDef = new GroupDef(
                "group-1",
                createTextOnlyConcept("Test Group"),
                List.of(),
                List.of(numeratorPop, denominatorPop),
                MeasureScoring.PROPORTION,
                false,
                createImprovementNotationCode("increase"),
                dateBasis);

        // VERIFY: aggregationResult is null (no scoring performed)
        assertNull(numeratorPop.getAggregationResult());
        assertNull(denominatorPop.getAggregationResult());

        // VERIFY: getMeasureScore returns null when score is null
        assertNull(groupDef.getScore());
    }

    @Test
    void testGetMeasureScore_ZeroScore_IncreaseNotation() {
        // Setup: Group with zero score and increase notation
        CodeDef encounterBasis = createPopulationBasisCode("Encounter");
        PopulationDef numeratorPop =
                createPopulationDef("num-1", MeasurePopulationType.NUMERATOR, Set.of(), encounterBasis); // No subjects
        PopulationDef denominatorPop = createPopulationDef(
                "den-1",
                MeasurePopulationType.DENOMINATOR,
                Set.of("patient1", "patient2", "patient3", "patient4"),
                encounterBasis);

        GroupDef groupDef = new GroupDef(
                "group-1",
                createTextOnlyConcept("Test Group"),
                List.of(),
                List.of(numeratorPop, denominatorPop),
                MeasureScoring.PROPORTION,
                false,
                createImprovementNotationCode("increase"),
                encounterBasis);

        scorer.scoreGroup("http://example.com/Measure/test", groupDef);

        // VERIFY: aggregationResult is null (PROPORTION measure)
        assertNull(numeratorPop.getAggregationResult());
        assertNull(denominatorPop.getAggregationResult());

        // VERIFY: Score is 0/4 = 0.0
        assertEquals(0.0, groupDef.getScore(), 0.001);
    }

    @Test
    void testGetMeasureScore_NegativeScore_ReturnsNull() {
        // Setup: Group with manually set negative score (simulating applySetMembership=false scenario)
        CodeDef stringBasis = createPopulationBasisCode("String");
        PopulationDef numeratorPop = createPopulationDef(
                "num-1", MeasurePopulationType.NUMERATOR, Set.of("patient1", "patient2", "patient3"), stringBasis);
        PopulationDef denominatorPop = createPopulationDef(
                "den-1",
                MeasurePopulationType.DENOMINATOR,
                Set.of("patient1", "patient2", "patient3", "patient4"),
                stringBasis);

        GroupDef groupDef = new GroupDef(
                "group-1",
                createTextOnlyConcept("Test Group"),
                List.of(),
                List.of(numeratorPop, denominatorPop),
                MeasureScoring.PROPORTION,
                false,
                createImprovementNotationCode("increase"),
                stringBasis);

        // Manually set negative score to simulate strange value scenario
        groupDef.setScoreAndAdaptToImprovementNotation(-0.5);

        // VERIFY: getMeasureScore returns null for negative scores
        assertNull(groupDef.getScore());
    }

    @Test
    void testGetMeasureScore_PositiveScore_IncreaseNotation() {
        // Setup: Group with positive score and increase notation
        CodeDef dateBasis = createPopulationBasisCode("date");
        PopulationDef numeratorPop = createPopulationDef(
                "num-1", MeasurePopulationType.NUMERATOR, Set.of("patient1", "patient2", "patient3"), dateBasis);
        PopulationDef denominatorPop = createPopulationDef(
                "den-1",
                MeasurePopulationType.DENOMINATOR,
                Set.of("patient1", "patient2", "patient3", "patient4"),
                dateBasis);

        GroupDef groupDef = new GroupDef(
                "group-1",
                createTextOnlyConcept("Test Group"),
                List.of(),
                List.of(numeratorPop, denominatorPop),
                MeasureScoring.PROPORTION,
                false,
                createImprovementNotationCode("increase"),
                dateBasis);

        scorer.scoreGroup("http://example.com/Measure/test", groupDef);

        // VERIFY: aggregationResult is null (PROPORTION measure)
        assertNull(numeratorPop.getAggregationResult());
        assertNull(denominatorPop.getAggregationResult());

        // VERIFY: Score is 3/4 = 0.75
        assertEquals(0.75, groupDef.getScore(), 0.001);
    }

    @Test
    void testGetMeasureScore_PositiveScore_DecreaseNotation() {
        // Setup: Group with positive score and decrease notation
        CodeDef booleanBasis = createBooleanBasisCode();
        PopulationDef numeratorPop = createPopulationDef(
                "num-1", MeasurePopulationType.NUMERATOR, Set.of("patient1", "patient2", "patient3"), booleanBasis);
        PopulationDef denominatorPop = createPopulationDef(
                "den-1",
                MeasurePopulationType.DENOMINATOR,
                Set.of("patient1", "patient2", "patient3", "patient4"),
                booleanBasis);

        GroupDef groupDef = new GroupDef(
                "group-1",
                createTextOnlyConcept("Test Group"),
                List.of(),
                List.of(numeratorPop, denominatorPop),
                MeasureScoring.PROPORTION,
                false,
                createImprovementNotationCode("decrease"), // DECREASE notation
                booleanBasis);

        scorer.scoreGroup("http://example.com/Measure/test", groupDef);

        // VERIFY: aggregationResult is null (PROPORTION measure)
        assertNull(numeratorPop.getAggregationResult());
        assertNull(denominatorPop.getAggregationResult());

        // VERIFY: getMeasureScore returns (1 - score) = 0.25 for decrease notation
        assertEquals(0.25, groupDef.getScore(), 0.001);
    }

    // ============================================================================
    // Population Basis Tests - Boolean vs Non-Boolean Counting
    // ============================================================================

    /**
     * Test that demonstrates population basis "boolean" counts unique subjects.
     * <p>
     * With boolean basis, PopulationDef.getCount() calls getSubjects().size().
     * Even if a subject has multiple resources, they are counted only once.
     * <p>
     * This test has:
     * - Numerator: 2 subjects (patient1 with 3 encounters, patient2 with 2 encounters)
     * - Denominator: 3 subjects (patient1, patient2, patient3 each with multiple encounters)
     * - Expected score: 2 subjects / 3 subjects = 0.667
     */
    @Test
    void testScoreGroup_BooleanBasis_CountsUniqueSubjects() {
        // Create numerator with 2 subjects, each having multiple resources
        ConceptDef numeratorCode = createMeasurePopulationConcept(MeasurePopulationType.NUMERATOR);
        CodeDef booleanBasis = createBooleanBasisCode();
        PopulationDef numeratorPop = new PopulationDef(
                "num-1", numeratorCode, MeasurePopulationType.NUMERATOR, "Numerator", booleanBasis, null);

        // Patient1: 3 encounters in numerator
        numeratorPop.addResource("patient1", "Encounter/enc1");
        numeratorPop.addResource("patient1", "Encounter/enc2");
        numeratorPop.addResource("patient1", "Encounter/enc3");

        // Patient2: 2 encounters in numerator
        numeratorPop.addResource("patient2", "Encounter/enc4");
        numeratorPop.addResource("patient2", "Encounter/enc5");

        // Create denominator with 3 subjects, each having multiple resources
        ConceptDef denominatorCode = createMeasurePopulationConcept(MeasurePopulationType.DENOMINATOR);
        CodeDef booleanBasis2 = createBooleanBasisCode();
        PopulationDef denominatorPop = new PopulationDef(
                "den-1", denominatorCode, MeasurePopulationType.DENOMINATOR, "Denominator", booleanBasis2, null);

        // Patient1: 3 encounters in denominator
        denominatorPop.addResource("patient1", "Encounter/enc1");
        denominatorPop.addResource("patient1", "Encounter/enc2");
        denominatorPop.addResource("patient1", "Encounter/enc3");

        // Patient2: 2 encounters in denominator
        denominatorPop.addResource("patient2", "Encounter/enc4");
        denominatorPop.addResource("patient2", "Encounter/enc5");

        // Patient3: 4 encounters in denominator (NOT in numerator)
        denominatorPop.addResource("patient3", "Encounter/enc6");
        denominatorPop.addResource("patient3", "Encounter/enc7");
        denominatorPop.addResource("patient3", "Encounter/enc8");
        denominatorPop.addResource("patient3", "Encounter/enc9");

        // CRITICAL: Use boolean basis
        GroupDef groupDef = new GroupDef(
                "group-1",
                createTextOnlyConcept("Boolean Basis Test"),
                List.of(),
                List.of(numeratorPop, denominatorPop),
                MeasureScoring.PROPORTION,
                false,
                createImprovementNotationCode("increase"),
                createPopulationBasisCode("boolean"));

        // Verify counts BEFORE scoring
        // Boolean basis: count unique subjects, NOT resources
        assertEquals(2, numeratorPop.getCount()); // 2 subjects (patient1, patient2)
        assertEquals(3, denominatorPop.getCount()); // 3 subjects (patient1, patient2, patient3)

        // Execute scoring
        scorer.scoreGroup("http://example.com/Measure/test", groupDef);

        // VERIFY: aggregationResult is null (PROPORTION measure)
        assertNull(numeratorPop.getAggregationResult());
        assertNull(denominatorPop.getAggregationResult());

        // VERIFY: Score is based on unique subjects, NOT resources
        // 2 subjects / 3 subjects = 0.667
        assertEquals(0.667, groupDef.getScore(), 0.001);
    }

    /**
     * Test that demonstrates non-boolean basis counts all subject resources.
     * <p>
     * With Encounter basis, PopulationDef.getCount() calls getAllSubjectResources().size().
     * Each resource is counted, even if multiple resources belong to the same subject.
     * <p>
     * This test uses the SAME population setup as testScoreGroup_BooleanBasis_CountsUniqueSubjects
     * but with "Encounter" basis instead of "boolean".
     * <p>
     * Expected:
     * - Numerator: 5 encounters (3 for patient1 + 2 for patient2)
     * - Denominator: 9 encounters (3 for patient1 + 2 for patient2 + 4 for patient3)
     * - Expected score: 5 encounters / 9 encounters = 0.556
     */
    @Test
    void testScoreGroup_EncounterBasis_CountsAllResources() {
        // Create numerator with 2 subjects, each having multiple resources
        ConceptDef numeratorCode = createMeasurePopulationConcept(MeasurePopulationType.NUMERATOR);
        CodeDef encounterBasis = createPopulationBasisCode("Encounter");
        PopulationDef numeratorPop = new PopulationDef(
                "num-1", numeratorCode, MeasurePopulationType.NUMERATOR, "Numerator", encounterBasis, null);

        // Patient1: 3 encounters in numerator
        numeratorPop.addResource("patient1", "Encounter/enc1");
        numeratorPop.addResource("patient1", "Encounter/enc2");
        numeratorPop.addResource("patient1", "Encounter/enc3");

        // Patient2: 2 encounters in numerator
        numeratorPop.addResource("patient2", "Encounter/enc4");
        numeratorPop.addResource("patient2", "Encounter/enc5");

        // Create denominator with 3 subjects, each having multiple resources
        ConceptDef denominatorCode = createMeasurePopulationConcept(MeasurePopulationType.DENOMINATOR);
        PopulationDef denominatorPop = new PopulationDef(
                "den-1", denominatorCode, MeasurePopulationType.DENOMINATOR, "Denominator", encounterBasis, null);

        // Patient1: 3 encounters in denominator
        denominatorPop.addResource("patient1", "Encounter/enc1");
        denominatorPop.addResource("patient1", "Encounter/enc2");
        denominatorPop.addResource("patient1", "Encounter/enc3");

        // Patient2: 2 encounters in denominator
        denominatorPop.addResource("patient2", "Encounter/enc4");
        denominatorPop.addResource("patient2", "Encounter/enc5");

        // Patient3: 4 encounters in denominator (NOT in numerator)
        denominatorPop.addResource("patient3", "Encounter/enc6");
        denominatorPop.addResource("patient3", "Encounter/enc7");
        denominatorPop.addResource("patient3", "Encounter/enc8");
        denominatorPop.addResource("patient3", "Encounter/enc9");

        // CRITICAL: Use Encounter basis (non-boolean)
        GroupDef groupDef = new GroupDef(
                "group-1",
                createTextOnlyConcept("Encounter Basis Test"),
                List.of(),
                List.of(numeratorPop, denominatorPop),
                MeasureScoring.PROPORTION,
                false,
                createImprovementNotationCode("increase"),
                encounterBasis);

        // Verify counts BEFORE scoring
        // Encounter basis: count ALL resources, not just unique subjects
        assertEquals(5, numeratorPop.getCount()); // 5 encounters (3 + 2)
        assertEquals(9, denominatorPop.getCount()); // 9 encounters (3 + 2 + 4)

        // Execute scoring
        scorer.scoreGroup("http://example.com/Measure/test", groupDef);

        // VERIFY: aggregationResult is null (PROPORTION measure)
        assertNull(numeratorPop.getAggregationResult());
        assertNull(denominatorPop.getAggregationResult());

        // VERIFY: Score is based on encounter count, NOT subject count
        // 5 encounters / 9 encounters = 0.556
        assertEquals(0.556, groupDef.getScore(), 0.001);
    }

    // ============================================================================
    // Additional Test Coverage - Cohort and Edge Cases
    // ============================================================================

    @Test
    void testScoreGroup_CohortMeasure_NoScoreSet() {
        // Setup: Cohort measure with only INITIALPOPULATION
        CodeDef booleanBasis = createBooleanBasisCode();
        PopulationDef initialPopulation = createPopulationDef(
                "ip-1",
                MeasurePopulationType.INITIALPOPULATION,
                Set.of("p1", "p2", "p3", "p4", "p5", "p6", "p7", "p8", "p9", "p10"),
                booleanBasis);

        GroupDef groupDef = new GroupDef(
                "group-1",
                createTextOnlyConcept("Cohort Measure Test"),
                List.of(), // No stratifiers
                List.of(initialPopulation),
                MeasureScoring.COHORT,
                false,
                createImprovementNotationCode("increase"),
                booleanBasis);

        // Verify score is null before scoring
        assertNull(groupDef.getScore());

        // Execute
        scorer.scoreGroup("http://example.com/Measure/cohort-test", groupDef);

        // VERIFY: aggregationResult is null (COHORT measure)
        assertNull(initialPopulation.getAggregationResult());

        // VERIFY: Cohort measures do not have scores
        assertNull(groupDef.getScore());
    }

    @Test
    void testScoreGroup_MissingScoringType_ThrowsException() {
        // Setup: GroupDef with null scoring type
        CodeDef booleanBasis = createBooleanBasisCode();
        PopulationDef numeratorPop =
                createPopulationDef("num-1", MeasurePopulationType.NUMERATOR, Set.of("p1", "p2", "p3"), booleanBasis);
        PopulationDef denominatorPop = createPopulationDef(
                "den-1", MeasurePopulationType.DENOMINATOR, Set.of("p1", "p2", "p3", "p4"), booleanBasis);

        GroupDef groupDef = new GroupDef(
                "group-1",
                createTextOnlyConcept("Missing Scoring Type Test"),
                List.of(),
                List.of(numeratorPop, denominatorPop),
                null, // NULL scoring type
                false,
                createImprovementNotationCode("increase"),
                booleanBasis);

        // Execute and verify exception
        Exception exception = assertThrows(
                Exception.class, () -> scorer.scoreGroup("http://example.com/Measure/missing-scoring", groupDef));

        // Verify exception message contains useful information
        assertTrue(exception.getMessage().contains("scoring"));
    }

    // ============================================================================
    // Ratio with Observations Tests - Group and Stratum Level
    // ============================================================================

    @Test
    void testScoreGroup_RatioWithObservations_GroupLevel() {
        // Setup: RATIO measure with separate numerator/denominator MEASUREOBSERVATION populations
        CodeDef booleanBasis = createBooleanBasisCode();
        PopulationDef initialPopulation = createPopulationDef(
                "ip-1", MeasurePopulationType.INITIALPOPULATION, Set.of("p1", "p2", "p3"), booleanBasis);
        PopulationDef measurePopulation = createPopulationDef(
                "mp-1", MeasurePopulationType.MEASUREPOPULATION, Set.of("p1", "p2", "p3"), booleanBasis);

        // Create standard NUMERATOR and DENOMINATOR populations (referenced by measure observations)
        PopulationDef numeratorPop =
                createPopulationDef("num-1", MeasurePopulationType.NUMERATOR, Set.of("p1", "p2", "p3"), booleanBasis);
        PopulationDef denominatorPop =
                createPopulationDef("den-1", MeasurePopulationType.DENOMINATOR, Set.of("p1", "p2", "p3"), booleanBasis);

        // Create numerator MEASUREOBSERVATION with criteriaReference to numerator
        ConceptDef numObsCode = createMeasurePopulationConcept(MeasurePopulationType.MEASUREOBSERVATION);
        PopulationDef numeratorMeasureObs = new PopulationDef(
                "num-obs-1",
                numObsCode,
                MeasurePopulationType.MEASUREOBSERVATION,
                "NumeratorExpression",
                booleanBasis,
                "num-1", // criteriaReference to NUMERATOR population
                ContinuousVariableObservationAggregateMethod.SUM,
                null);

        // Add numerator observations
        Map<String, QuantityDef> numObs1 = new HashMap<>();
        numObs1.put("obs-num-1", new QuantityDef(10.0));
        numeratorMeasureObs.addResource("p1", numObs1);

        Map<String, QuantityDef> numObs2 = new HashMap<>();
        numObs2.put("obs-num-2", new QuantityDef(20.0));
        numeratorMeasureObs.addResource("p2", numObs2);

        Map<String, QuantityDef> numObs3 = new HashMap<>();
        numObs3.put("obs-num-3", new QuantityDef(30.0));
        numeratorMeasureObs.addResource("p3", numObs3);

        // Create denominator MEASUREOBSERVATION with criteriaReference to denominator
        ConceptDef denObsCode = createMeasurePopulationConcept(MeasurePopulationType.MEASUREOBSERVATION);
        PopulationDef denominatorMeasureObs = new PopulationDef(
                "den-obs-1",
                denObsCode,
                MeasurePopulationType.MEASUREOBSERVATION,
                "DenominatorExpression",
                booleanBasis,
                "den-1", // criteriaReference to DENOMINATOR population
                ContinuousVariableObservationAggregateMethod.SUM,
                null);

        // Add denominator observations
        Map<String, QuantityDef> denObs1 = new HashMap<>();
        denObs1.put("obs-den-1", new QuantityDef(5.0));
        denominatorMeasureObs.addResource("p1", denObs1);

        Map<String, QuantityDef> denObs2 = new HashMap<>();
        denObs2.put("obs-den-2", new QuantityDef(10.0));
        denominatorMeasureObs.addResource("p2", denObs2);

        Map<String, QuantityDef> denObs3 = new HashMap<>();
        denObs3.put("obs-den-3", new QuantityDef(15.0));
        denominatorMeasureObs.addResource("p3", denObs3);

        // Create GroupDef with RATIO scoring
        GroupDef groupDef = new GroupDef(
                "group-1",
                createTextOnlyConcept("Ratio with Observations Test"),
                List.of(), // No stratifiers
                List.of(
                        initialPopulation,
                        measurePopulation,
                        numeratorPop,
                        denominatorPop,
                        numeratorMeasureObs,
                        denominatorMeasureObs),
                MeasureScoring.RATIO,
                false,
                createImprovementNotationCode("increase"),
                booleanBasis);

        // Verify score is null before scoring
        assertNull(groupDef.getScore());

        // Execute
        scorer.scoreGroup("http://example.com/Measure/ratio-obs-test", groupDef);

        // VERIFY: Non-observation populations should have null aggregationResult
        assertNull(initialPopulation.getAggregationResult());
        assertNull(measurePopulation.getAggregationResult());
        assertNull(numeratorPop.getAggregationResult()); // Regular NUMERATOR
        assertNull(denominatorPop.getAggregationResult()); // Regular DENOMINATOR

        // VERIFY: MEASUREOBSERVATION populations should have aggregationResult
        assertEquals(3, numeratorMeasureObs.getCount());
        assertNotNull(numeratorMeasureObs.getAggregationResult());
        assertEquals(60.0, numeratorMeasureObs.getAggregationResult(), 0.001); // 10+20+30

        assertEquals(3, denominatorMeasureObs.getCount());
        assertNotNull(denominatorMeasureObs.getAggregationResult());
        assertEquals(30.0, denominatorMeasureObs.getAggregationResult(), 0.001); // 5+10+15

        // VERIFY: Score is 60.0 / 30.0 = 2.0
        assertEquals(2.0, groupDef.getScore(), 0.001);
    }

    @Test
    void testScoreGroup_RatioWithObservations_ZeroCount() {
        // Setup: RATIO measure with MEASUREOBSERVATION but NO observations
        CodeDef booleanBasis = createBooleanBasisCode();
        PopulationDef initialPopulation =
                createPopulationDef("ip-1", MeasurePopulationType.INITIALPOPULATION, Set.of(), booleanBasis);

        PopulationDef numeratorPop =
                createPopulationDef("num-1", MeasurePopulationType.NUMERATOR, Set.of(), booleanBasis);
        PopulationDef denominatorPop =
                createPopulationDef("den-1", MeasurePopulationType.DENOMINATOR, Set.of(), booleanBasis);

        // MEASUREOBSERVATION populations with NO observations added
        ConceptDef numObsCode = createMeasurePopulationConcept(MeasurePopulationType.MEASUREOBSERVATION);
        PopulationDef numeratorMeasureObs = new PopulationDef(
                "num-obs-1",
                numObsCode,
                MeasurePopulationType.MEASUREOBSERVATION,
                "NumeratorExpression",
                booleanBasis,
                "num-1",
                ContinuousVariableObservationAggregateMethod.SUM,
                null);

        ConceptDef denObsCode = createMeasurePopulationConcept(MeasurePopulationType.MEASUREOBSERVATION);
        PopulationDef denominatorMeasureObs = new PopulationDef(
                "den-obs-1",
                denObsCode,
                MeasurePopulationType.MEASUREOBSERVATION,
                "DenominatorExpression",
                booleanBasis,
                "den-1",
                ContinuousVariableObservationAggregateMethod.SUM,
                null);

        GroupDef groupDef = new GroupDef(
                "group-1",
                createTextOnlyConcept("Ratio with Zero Observations"),
                List.of(),
                List.of(initialPopulation, numeratorPop, denominatorPop, numeratorMeasureObs, denominatorMeasureObs),
                MeasureScoring.RATIO,
                false,
                createImprovementNotationCode("increase"),
                booleanBasis);

        scorer.scoreGroup("http://example.com/Measure/ratio-zero-obs", groupDef);

        // VERIFY: All have null aggregationResult when count is zero
        assertNull(initialPopulation.getAggregationResult());
        assertNull(numeratorPop.getAggregationResult());
        assertNull(denominatorPop.getAggregationResult());
        assertNull(numeratorMeasureObs.getAggregationResult()); // Zero count
        assertNull(denominatorMeasureObs.getAggregationResult()); // Zero count
        assertNull(groupDef.getScore()); // Null score for zero denominator
    }

    @Test
    void testScoreGroup_RatioWithObservations_NullNumeratorPopulation() {
        // Setup: RATIO measure where numerator population is not found (null)
        // Should still set aggregation result for denominator
        CodeDef booleanBasis = createBooleanBasisCode();
        PopulationDef initialPopulation = createPopulationDef(
                "ip-1", MeasurePopulationType.INITIALPOPULATION, Set.of("p1", "p2", "p3"), booleanBasis);

        // Create DENOMINATOR population WITHOUT a matching NUMERATOR population
        PopulationDef denominatorPop =
                createPopulationDef("den-1", MeasurePopulationType.DENOMINATOR, Set.of("p1", "p2", "p3"), booleanBasis);

        // Create only denominator MEASUREOBSERVATION (no numerator reference)
        ConceptDef denObsCode = createMeasurePopulationConcept(MeasurePopulationType.MEASUREOBSERVATION);
        PopulationDef denominatorMeasureObs = new PopulationDef(
                "den-obs-1",
                denObsCode,
                MeasurePopulationType.MEASUREOBSERVATION,
                "DenominatorExpression",
                booleanBasis,
                "den-1", // criteriaReference to DENOMINATOR population
                ContinuousVariableObservationAggregateMethod.SUM,
                null);

        // Add denominator observations
        Map<String, QuantityDef> denObs1 = new HashMap<>();
        denObs1.put("obs-den-1", new QuantityDef(5.0));
        denominatorMeasureObs.addResource("p1", denObs1);

        Map<String, QuantityDef> denObs2 = new HashMap<>();
        denObs2.put("obs-den-2", new QuantityDef(10.0));
        denominatorMeasureObs.addResource("p2", denObs2);

        Map<String, QuantityDef> denObs3 = new HashMap<>();
        denObs3.put("obs-den-3", new QuantityDef(15.0));
        denominatorMeasureObs.addResource("p3", denObs3);

        GroupDef groupDef = new GroupDef(
                "group-1",
                createTextOnlyConcept("Ratio with Null Numerator"),
                List.of(),
                List.of(initialPopulation, denominatorPop, denominatorMeasureObs),
                MeasureScoring.RATIO,
                false,
                createImprovementNotationCode("increase"),
                booleanBasis);

        assertNull(groupDef.getScore());

        scorer.scoreGroup("http://example.com/Measure/ratio-null-num", groupDef);

        // VERIFY: Denominator aggregation result IS set even though numerator is null
        assertNotNull(denominatorMeasureObs.getAggregationResult());
        assertEquals(30.0, denominatorMeasureObs.getAggregationResult(), 0.001); // 5+10+15

        // VERIFY: Score is null (because numerator is null)
        assertNull(groupDef.getScore());
    }

    @Test
    void testScoreGroup_RatioWithObservations_NullDenominatorPopulation() {
        // Setup: RATIO measure where denominator population is not found (null)
        // Should still set aggregation result for numerator
        CodeDef booleanBasis = createBooleanBasisCode();
        PopulationDef initialPopulation = createPopulationDef(
                "ip-1", MeasurePopulationType.INITIALPOPULATION, Set.of("p1", "p2", "p3"), booleanBasis);

        // Create NUMERATOR population WITHOUT a matching DENOMINATOR population
        PopulationDef numeratorPop =
                createPopulationDef("num-1", MeasurePopulationType.NUMERATOR, Set.of("p1", "p2", "p3"), booleanBasis);

        // Create only numerator MEASUREOBSERVATION (no denominator reference)
        ConceptDef numObsCode = createMeasurePopulationConcept(MeasurePopulationType.MEASUREOBSERVATION);
        PopulationDef numeratorMeasureObs = new PopulationDef(
                "num-obs-1",
                numObsCode,
                MeasurePopulationType.MEASUREOBSERVATION,
                "NumeratorExpression",
                booleanBasis,
                "num-1", // criteriaReference to NUMERATOR population
                ContinuousVariableObservationAggregateMethod.SUM,
                null);

        // Add numerator observations
        Map<String, QuantityDef> numObs1 = new HashMap<>();
        numObs1.put("obs-num-1", new QuantityDef(10.0));
        numeratorMeasureObs.addResource("p1", numObs1);

        Map<String, QuantityDef> numObs2 = new HashMap<>();
        numObs2.put("obs-num-2", new QuantityDef(20.0));
        numeratorMeasureObs.addResource("p2", numObs2);

        Map<String, QuantityDef> numObs3 = new HashMap<>();
        numObs3.put("obs-num-3", new QuantityDef(30.0));
        numeratorMeasureObs.addResource("p3", numObs3);

        GroupDef groupDef = new GroupDef(
                "group-1",
                createTextOnlyConcept("Ratio with Null Denominator"),
                List.of(),
                List.of(initialPopulation, numeratorPop, numeratorMeasureObs),
                MeasureScoring.RATIO,
                false,
                createImprovementNotationCode("increase"),
                booleanBasis);

        assertNull(groupDef.getScore());

        scorer.scoreGroup("http://example.com/Measure/ratio-null-den", groupDef);

        // VERIFY: Numerator aggregation result IS set even though denominator is null
        assertNotNull(numeratorMeasureObs.getAggregationResult());
        assertEquals(60.0, numeratorMeasureObs.getAggregationResult(), 0.001); // 10+20+30

        // VERIFY: Score is null (because denominator is null)
        assertNull(groupDef.getScore());
    }

    @Test
    void testScoreGroup_RatioWithObservations_BothPopulationsNull() {
        // Setup: RATIO measure where both numerator and denominator populations are not found
        CodeDef booleanBasis = createBooleanBasisCode();
        PopulationDef initialPopulation =
                createPopulationDef("ip-1", MeasurePopulationType.INITIALPOPULATION, Set.of("p1", "p2"), booleanBasis);

        // Create MEASUREOBSERVATION without any matching NUMERATOR or DENOMINATOR populations
        ConceptDef obsCode = createMeasurePopulationConcept(MeasurePopulationType.MEASUREOBSERVATION);
        PopulationDef measureObs = new PopulationDef(
                "obs-1",
                obsCode,
                MeasurePopulationType.MEASUREOBSERVATION,
                "Expression",
                booleanBasis,
                "nonexistent-1", // No matching population
                ContinuousVariableObservationAggregateMethod.SUM,
                null);

        GroupDef groupDef = new GroupDef(
                "group-1",
                createTextOnlyConcept("Ratio with Both Null"),
                List.of(),
                List.of(initialPopulation, measureObs),
                MeasureScoring.RATIO,
                false,
                createImprovementNotationCode("increase"),
                booleanBasis);

        assertNull(groupDef.getScore());

        scorer.scoreGroup("http://example.com/Measure/ratio-both-null", groupDef);

        // VERIFY: No aggregation results are set (both populations null)
        assertNull(measureObs.getAggregationResult());

        // VERIFY: Score is null
        assertNull(groupDef.getScore());
    }

    @Test
    void testScoreGroup_RatioWithObservations_NullAggregateForNumerator() {
        // Setup: RATIO measure where numerator aggregate calculation returns null
        // (e.g., no observations for numerator)
        // Should still set denominator aggregation result
        CodeDef booleanBasis = createBooleanBasisCode();
        PopulationDef initialPopulation =
                createPopulationDef("ip-1", MeasurePopulationType.INITIALPOPULATION, Set.of("p1", "p2"), booleanBasis);

        PopulationDef numeratorPop =
                createPopulationDef("num-1", MeasurePopulationType.NUMERATOR, Set.of("p1", "p2"), booleanBasis);
        PopulationDef denominatorPop =
                createPopulationDef("den-1", MeasurePopulationType.DENOMINATOR, Set.of("p1", "p2"), booleanBasis);

        // Numerator MEASUREOBSERVATION with NO observations
        ConceptDef numObsCode = createMeasurePopulationConcept(MeasurePopulationType.MEASUREOBSERVATION);
        PopulationDef numeratorMeasureObs = new PopulationDef(
                "num-obs-1",
                numObsCode,
                MeasurePopulationType.MEASUREOBSERVATION,
                "NumeratorExpression",
                booleanBasis,
                "num-1",
                ContinuousVariableObservationAggregateMethod.SUM,
                null);
        // No observations added - will result in null aggregate

        // Denominator MEASUREOBSERVATION with observations
        ConceptDef denObsCode = createMeasurePopulationConcept(MeasurePopulationType.MEASUREOBSERVATION);
        PopulationDef denominatorMeasureObs = new PopulationDef(
                "den-obs-1",
                denObsCode,
                MeasurePopulationType.MEASUREOBSERVATION,
                "DenominatorExpression",
                booleanBasis,
                "den-1",
                ContinuousVariableObservationAggregateMethod.SUM,
                null);

        Map<String, QuantityDef> denObs1 = new HashMap<>();
        denObs1.put("obs-den-1", new QuantityDef(10.0));
        denominatorMeasureObs.addResource("p1", denObs1);

        GroupDef groupDef = new GroupDef(
                "group-1",
                createTextOnlyConcept("Ratio with Null Numerator Aggregate"),
                List.of(),
                List.of(initialPopulation, numeratorPop, denominatorPop, numeratorMeasureObs, denominatorMeasureObs),
                MeasureScoring.RATIO,
                false,
                createImprovementNotationCode("increase"),
                booleanBasis);

        scorer.scoreGroup("http://example.com/Measure/ratio-null-num-agg", groupDef);

        // VERIFY: Numerator aggregation result is null (no observations)
        assertNull(numeratorMeasureObs.getAggregationResult());

        // VERIFY: Denominator aggregation result IS set
        assertNotNull(denominatorMeasureObs.getAggregationResult());
        assertEquals(10.0, denominatorMeasureObs.getAggregationResult(), 0.001);

        // VERIFY: Score is null (because numerator aggregate is null)
        assertNull(groupDef.getScore());
    }

    @Test
    void testScoreGroup_RatioWithObservations_AvgAggregation() {
        // Setup: RATIO measure with AVG aggregation (not SUM)
        // Numerator obs: 10, 20, 30  AVG = 20.0
        // Denominator obs: 5, 10, 15  AVG = 10.0
        // Score: 20 / 10 = 2.0
        CodeDef booleanBasis = createBooleanBasisCode();
        PopulationDef initialPopulation = createPopulationDef(
                "ip-1", MeasurePopulationType.INITIALPOPULATION, Set.of("p1", "p2", "p3"), booleanBasis);
        PopulationDef measurePopulation = createPopulationDef(
                "mp-1", MeasurePopulationType.MEASUREPOPULATION, Set.of("p1", "p2", "p3"), booleanBasis);

        PopulationDef numeratorPop =
                createPopulationDef("num-1", MeasurePopulationType.NUMERATOR, Set.of("p1", "p2", "p3"), booleanBasis);
        PopulationDef denominatorPop =
                createPopulationDef("den-1", MeasurePopulationType.DENOMINATOR, Set.of("p1", "p2", "p3"), booleanBasis);

        // Create numerator MEASUREOBSERVATION with AVG aggregation
        ConceptDef numObsCode = createMeasurePopulationConcept(MeasurePopulationType.MEASUREOBSERVATION);
        PopulationDef numeratorMeasureObs = new PopulationDef(
                "num-obs-1",
                numObsCode,
                MeasurePopulationType.MEASUREOBSERVATION,
                "NumeratorExpression",
                booleanBasis,
                "num-1",
                ContinuousVariableObservationAggregateMethod.AVG,
                null); // AVG instead of SUM

        Map<String, QuantityDef> numObs1 = new HashMap<>();
        numObs1.put("obs-num-1", new QuantityDef(10.0));
        numeratorMeasureObs.addResource("p1", numObs1);

        Map<String, QuantityDef> numObs2 = new HashMap<>();
        numObs2.put("obs-num-2", new QuantityDef(20.0));
        numeratorMeasureObs.addResource("p2", numObs2);

        Map<String, QuantityDef> numObs3 = new HashMap<>();
        numObs3.put("obs-num-3", new QuantityDef(30.0));
        numeratorMeasureObs.addResource("p3", numObs3);

        // Create denominator MEASUREOBSERVATION with AVG aggregation
        ConceptDef denObsCode = createMeasurePopulationConcept(MeasurePopulationType.MEASUREOBSERVATION);
        PopulationDef denominatorMeasureObs = new PopulationDef(
                "den-obs-1",
                denObsCode,
                MeasurePopulationType.MEASUREOBSERVATION,
                "DenominatorExpression",
                booleanBasis,
                "den-1",
                ContinuousVariableObservationAggregateMethod.AVG,
                null); // AVG instead of SUM

        Map<String, QuantityDef> denObs1 = new HashMap<>();
        denObs1.put("obs-den-1", new QuantityDef(5.0));
        denominatorMeasureObs.addResource("p1", denObs1);

        Map<String, QuantityDef> denObs2 = new HashMap<>();
        denObs2.put("obs-den-2", new QuantityDef(10.0));
        denominatorMeasureObs.addResource("p2", denObs2);

        Map<String, QuantityDef> denObs3 = new HashMap<>();
        denObs3.put("obs-den-3", new QuantityDef(15.0));
        denominatorMeasureObs.addResource("p3", denObs3);

        GroupDef groupDef = new GroupDef(
                "group-1",
                createTextOnlyConcept("Ratio with AVG Aggregation"),
                List.of(),
                List.of(
                        initialPopulation,
                        measurePopulation,
                        numeratorPop,
                        denominatorPop,
                        numeratorMeasureObs,
                        denominatorMeasureObs),
                MeasureScoring.RATIO,
                false,
                createImprovementNotationCode("increase"),
                booleanBasis);

        assertNull(groupDef.getScore());

        scorer.scoreGroup("http://example.com/Measure/ratio-avg-test", groupDef);

        // VERIFY: Non-observation populations have null aggregationResult
        assertNull(initialPopulation.getAggregationResult());
        assertNull(measurePopulation.getAggregationResult());
        assertNull(numeratorPop.getAggregationResult());
        assertNull(denominatorPop.getAggregationResult());

        // VERIFY: MEASUREOBSERVATION populations have AVG aggregationResult
        assertEquals(3, numeratorMeasureObs.getCount());
        assertNotNull(numeratorMeasureObs.getAggregationResult());
        assertEquals(20.0, numeratorMeasureObs.getAggregationResult(), 0.001); // AVG: (10+20+30)/3 = 20.0

        assertEquals(3, denominatorMeasureObs.getCount());
        assertNotNull(denominatorMeasureObs.getAggregationResult());
        assertEquals(10.0, denominatorMeasureObs.getAggregationResult(), 0.001); // AVG: (5+10+15)/3 = 10.0

        // VERIFY: Score is 20.0 / 10.0 = 2.0
        assertEquals(2.0, groupDef.getScore(), 0.001);
    }

    @Test
    void testScoreStratifier_RatioWithObservations_StratumLevel() {
        // Setup: Ratio measure with stratifier by gender
        // Male patients: p1, p2, p3
        // Female patients: p4, p5

        CodeDef booleanBasis = createBooleanBasisCode();
        PopulationDef initialPopulation = createPopulationDef(
                "ip-1", MeasurePopulationType.INITIALPOPULATION, Set.of("p1", "p2", "p3", "p4", "p5"), booleanBasis);

        // Create standard NUMERATOR and DENOMINATOR populations
        PopulationDef numeratorPop = createPopulationDef(
                "num-1", MeasurePopulationType.NUMERATOR, Set.of("p1", "p2", "p3", "p4", "p5"), booleanBasis);
        PopulationDef denominatorPop = createPopulationDef(
                "den-1", MeasurePopulationType.DENOMINATOR, Set.of("p1", "p2", "p3", "p4", "p5"), booleanBasis);

        // Create numerator MEASUREOBSERVATION
        ConceptDef numObsCode = createMeasurePopulationConcept(MeasurePopulationType.MEASUREOBSERVATION);
        PopulationDef numeratorMeasureObs = new PopulationDef(
                "num-obs-1",
                numObsCode,
                MeasurePopulationType.MEASUREOBSERVATION,
                "NumeratorExpression",
                booleanBasis,
                "num-1",
                ContinuousVariableObservationAggregateMethod.SUM,
                null);

        // Male numerator observations: 10 + 15 + 15 = 40
        Map<String, QuantityDef> numObs1 = new HashMap<>();
        numObs1.put("p1", new QuantityDef(10.0));
        numeratorMeasureObs.addResource("p1", numObs1);

        Map<String, QuantityDef> numObs2 = new HashMap<>();
        numObs2.put("p2", new QuantityDef(15.0));
        numeratorMeasureObs.addResource("p2", numObs2);

        Map<String, QuantityDef> numObs3 = new HashMap<>();
        numObs3.put("p3", new QuantityDef(15.0));
        numeratorMeasureObs.addResource("p3", numObs3);

        // Female numerator observations: 10 + 20 = 30
        Map<String, QuantityDef> numObs4 = new HashMap<>();
        numObs4.put("p4", new QuantityDef(10.0));
        numeratorMeasureObs.addResource("p4", numObs4);

        Map<String, QuantityDef> numObs5 = new HashMap<>();
        numObs5.put("p5", new QuantityDef(20.0));
        numeratorMeasureObs.addResource("p5", numObs5);

        // Create denominator MEASUREOBSERVATION
        ConceptDef denObsCode = createMeasurePopulationConcept(MeasurePopulationType.MEASUREOBSERVATION);
        PopulationDef denominatorMeasureObs = new PopulationDef(
                "den-obs-1",
                denObsCode,
                MeasurePopulationType.MEASUREOBSERVATION,
                "DenominatorExpression",
                booleanBasis,
                "den-1",
                ContinuousVariableObservationAggregateMethod.SUM,
                null);

        // Male denominator observations: 5 + 7 + 8 = 20
        Map<String, QuantityDef> denObs1 = new HashMap<>();
        denObs1.put("p1", new QuantityDef(5.0));
        denominatorMeasureObs.addResource("p1", denObs1);

        Map<String, QuantityDef> denObs2 = new HashMap<>();
        denObs2.put("p2", new QuantityDef(7.0));
        denominatorMeasureObs.addResource("p2", denObs2);

        Map<String, QuantityDef> denObs3 = new HashMap<>();
        denObs3.put("p3", new QuantityDef(8.0));
        denominatorMeasureObs.addResource("p3", denObs3);

        // Female denominator observations: 4 + 6 = 10
        Map<String, QuantityDef> denObs4 = new HashMap<>();
        denObs4.put("p4", new QuantityDef(4.0));
        denominatorMeasureObs.addResource("p4", denObs4);

        Map<String, QuantityDef> denObs5 = new HashMap<>();
        denObs5.put("p5", new QuantityDef(6.0));
        denominatorMeasureObs.addResource("p5", denObs5);

        // Create stratum populations for Male stratum
        // Male stratum - MEASUREOBSERVATION populations
        StratumPopulationDef maleNumObs = new StratumPopulationDef(
                numeratorMeasureObs,
                Set.of("p1", "p2", "p3"), // subjectsQualifiedOrUnqualified
                Set.of(), // populationDefEvaluationResultIntersection
                List.of(), // resourceIdsForSubjectList
                MeasureStratifierType.VALUE,
                booleanBasis);

        StratumPopulationDef maleDenObs = new StratumPopulationDef(
                denominatorMeasureObs,
                Set.of("p1", "p2", "p3"),
                Set.of(),
                List.of(),
                MeasureStratifierType.VALUE,
                booleanBasis);

        StratifierComponentDef genderComponent =
                new StratifierComponentDef("gender-component", createTextOnlyConcept("Gender"), "Gender");

        // Create measure observation cache for male stratum
        MeasureObservationStratumCache maleCache = new MeasureObservationStratumCache(maleNumObs, maleDenObs);

        StratumDef maleStratum = new StratumDef(
                List.of(maleNumObs, maleDenObs),
                Set.of(new StratumValueDef(new StratumValueWrapper("male"), genderComponent)),
                Set.of("p1", "p2", "p3"),
                maleCache);

        // Female stratum - MEASUREOBSERVATION populations
        StratumPopulationDef femaleNumObs = new StratumPopulationDef(
                numeratorMeasureObs,
                Set.of("p4", "p5"),
                Set.of(),
                List.of(),
                MeasureStratifierType.VALUE,
                booleanBasis);

        StratumPopulationDef femaleDenObs = new StratumPopulationDef(
                denominatorMeasureObs,
                Set.of("p4", "p5"),
                Set.of(),
                List.of(),
                MeasureStratifierType.VALUE,
                booleanBasis);

        // Create measure observation cache for female stratum
        MeasureObservationStratumCache femaleCache = new MeasureObservationStratumCache(femaleNumObs, femaleDenObs);

        StratumDef femaleStratum = new StratumDef(
                List.of(femaleNumObs, femaleDenObs),
                Set.of(new StratumValueDef(new StratumValueWrapper("female"), genderComponent)),
                Set.of("p4", "p5"),
                femaleCache);

        // Create StratifierDef with strata
        StratifierDef stratifierDef = new StratifierDef(
                "gender-stratifier", createTextOnlyConcept("Gender Stratifier"), "Gender", MeasureStratifierType.VALUE);
        stratifierDef.addAllStratum(List.of(maleStratum, femaleStratum));

        // Create GroupDef
        GroupDef groupDef = new GroupDef(
                "group-1",
                createTextOnlyConcept("Ratio with Observations Stratified"),
                List.of(stratifierDef),
                List.of(initialPopulation, numeratorPop, denominatorPop, numeratorMeasureObs, denominatorMeasureObs),
                MeasureScoring.RATIO,
                false,
                createImprovementNotationCode("increase"),
                booleanBasis);

        // Verify scores are null before scoring
        assertNull(maleStratum.getScore());
        assertNull(femaleStratum.getScore());

        // Execute
        scorer.scoreGroup("http://example.com/Measure/ratio-obs-stratified", groupDef);

        // VERIFY: Group-level MEASUREOBSERVATION populations have aggregationResult
        assertEquals(5, numeratorMeasureObs.getCount());
        assertNotNull(numeratorMeasureObs.getAggregationResult());
        assertEquals(70.0, numeratorMeasureObs.getAggregationResult(), 0.001); // 40+30 (both strata)

        assertEquals(5, denominatorMeasureObs.getCount());
        assertNotNull(denominatorMeasureObs.getAggregationResult());
        assertEquals(30.0, denominatorMeasureObs.getAggregationResult(), 0.001); // 20+10 (both strata)

        // VERIFY: Non-observation populations have null aggregationResult
        assertNull(initialPopulation.getAggregationResult());
        assertNull(numeratorPop.getAggregationResult()); // Regular NUMERATOR
        assertNull(denominatorPop.getAggregationResult()); // Regular DENOMINATOR

        // VERIFY: Male stratum score = 40/20 = 2.0
        assertEquals(2.0, maleStratum.getScore(), 0.001);

        // VERIFY: Female stratum score = 30/10 = 3.0
        assertEquals(3.0, femaleStratum.getScore(), 0.001);
    }

    // ============================================================================
    // Per-Stratum Aggregation Result Tests (StratumPopulationDef.aggregationResult)
    // ============================================================================

    @Test
    void testScoreStratifier_RatioWithObservations_PerStratumAggregationResults() {
        // Setup: Ratio measure with stratifier by gender
        // Verify that per-stratum aggregation results are persisted on StratumPopulationDef
        // Male: num_agg=40 (SUM of 10+15+15), den_agg=20 (SUM of 5+7+8), score=2.0
        // Female: num_agg=30 (SUM of 10+20), den_agg=10 (SUM of 4+6), score=3.0

        CodeDef booleanBasis = createBooleanBasisCode();
        PopulationDef initialPopulation = createPopulationDef(
                "ip-1", MeasurePopulationType.INITIALPOPULATION, Set.of("p1", "p2", "p3", "p4", "p5"), booleanBasis);
        PopulationDef numeratorPop = createPopulationDef(
                "num-1", MeasurePopulationType.NUMERATOR, Set.of("p1", "p2", "p3", "p4", "p5"), booleanBasis);
        PopulationDef denominatorPop = createPopulationDef(
                "den-1", MeasurePopulationType.DENOMINATOR, Set.of("p1", "p2", "p3", "p4", "p5"), booleanBasis);

        // Numerator MEASUREOBSERVATION with SUM
        ConceptDef numObsCode = createMeasurePopulationConcept(MeasurePopulationType.MEASUREOBSERVATION);
        PopulationDef numeratorMeasureObs = new PopulationDef(
                "num-obs-1",
                numObsCode,
                MeasurePopulationType.MEASUREOBSERVATION,
                "NumeratorExpression",
                booleanBasis,
                "num-1",
                ContinuousVariableObservationAggregateMethod.SUM,
                null);

        Map<String, QuantityDef> numObs1 = new HashMap<>();
        numObs1.put("p1", new QuantityDef(10.0));
        numeratorMeasureObs.addResource("p1", numObs1);
        Map<String, QuantityDef> numObs2 = new HashMap<>();
        numObs2.put("p2", new QuantityDef(15.0));
        numeratorMeasureObs.addResource("p2", numObs2);
        Map<String, QuantityDef> numObs3 = new HashMap<>();
        numObs3.put("p3", new QuantityDef(15.0));
        numeratorMeasureObs.addResource("p3", numObs3);
        Map<String, QuantityDef> numObs4 = new HashMap<>();
        numObs4.put("p4", new QuantityDef(10.0));
        numeratorMeasureObs.addResource("p4", numObs4);
        Map<String, QuantityDef> numObs5 = new HashMap<>();
        numObs5.put("p5", new QuantityDef(20.0));
        numeratorMeasureObs.addResource("p5", numObs5);

        // Denominator MEASUREOBSERVATION with SUM
        ConceptDef denObsCode = createMeasurePopulationConcept(MeasurePopulationType.MEASUREOBSERVATION);
        PopulationDef denominatorMeasureObs = new PopulationDef(
                "den-obs-1",
                denObsCode,
                MeasurePopulationType.MEASUREOBSERVATION,
                "DenominatorExpression",
                booleanBasis,
                "den-1",
                ContinuousVariableObservationAggregateMethod.SUM,
                null);

        Map<String, QuantityDef> denObs1 = new HashMap<>();
        denObs1.put("p1", new QuantityDef(5.0));
        denominatorMeasureObs.addResource("p1", denObs1);
        Map<String, QuantityDef> denObs2 = new HashMap<>();
        denObs2.put("p2", new QuantityDef(7.0));
        denominatorMeasureObs.addResource("p2", denObs2);
        Map<String, QuantityDef> denObs3 = new HashMap<>();
        denObs3.put("p3", new QuantityDef(8.0));
        denominatorMeasureObs.addResource("p3", denObs3);
        Map<String, QuantityDef> denObs4 = new HashMap<>();
        denObs4.put("p4", new QuantityDef(4.0));
        denominatorMeasureObs.addResource("p4", denObs4);
        Map<String, QuantityDef> denObs5 = new HashMap<>();
        denObs5.put("p5", new QuantityDef(6.0));
        denominatorMeasureObs.addResource("p5", denObs5);

        // Male stratum populations
        StratumPopulationDef maleNumObs = new StratumPopulationDef(
                numeratorMeasureObs,
                Set.of("p1", "p2", "p3"),
                Set.of(),
                List.of(),
                MeasureStratifierType.VALUE,
                booleanBasis);
        StratumPopulationDef maleDenObs = new StratumPopulationDef(
                denominatorMeasureObs,
                Set.of("p1", "p2", "p3"),
                Set.of(),
                List.of(),
                MeasureStratifierType.VALUE,
                booleanBasis);

        StratifierComponentDef genderComponent =
                new StratifierComponentDef("gender-component", createTextOnlyConcept("Gender"), "Gender");
        MeasureObservationStratumCache maleCache = new MeasureObservationStratumCache(maleNumObs, maleDenObs);

        StratumDef maleStratum = new StratumDef(
                List.of(maleNumObs, maleDenObs),
                Set.of(new StratumValueDef(new StratumValueWrapper("male"), genderComponent)),
                Set.of("p1", "p2", "p3"),
                maleCache);

        // Female stratum populations
        StratumPopulationDef femaleNumObs = new StratumPopulationDef(
                numeratorMeasureObs,
                Set.of("p4", "p5"),
                Set.of(),
                List.of(),
                MeasureStratifierType.VALUE,
                booleanBasis);
        StratumPopulationDef femaleDenObs = new StratumPopulationDef(
                denominatorMeasureObs,
                Set.of("p4", "p5"),
                Set.of(),
                List.of(),
                MeasureStratifierType.VALUE,
                booleanBasis);

        MeasureObservationStratumCache femaleCache = new MeasureObservationStratumCache(femaleNumObs, femaleDenObs);

        StratumDef femaleStratum = new StratumDef(
                List.of(femaleNumObs, femaleDenObs),
                Set.of(new StratumValueDef(new StratumValueWrapper("female"), genderComponent)),
                Set.of("p4", "p5"),
                femaleCache);

        StratifierDef stratifierDef = new StratifierDef(
                "gender-stratifier", createTextOnlyConcept("Gender Stratifier"), "Gender", MeasureStratifierType.VALUE);
        stratifierDef.addAllStratum(List.of(maleStratum, femaleStratum));

        GroupDef groupDef = new GroupDef(
                "group-1",
                createTextOnlyConcept("RCV Per-Stratum Aggregation Test"),
                List.of(stratifierDef),
                List.of(initialPopulation, numeratorPop, denominatorPop, numeratorMeasureObs, denominatorMeasureObs),
                MeasureScoring.RATIO,
                false,
                createImprovementNotationCode("increase"),
                booleanBasis);

        // Pre-scoring: no aggregation results
        assertNull(maleNumObs.getAggregationResult());
        assertNull(maleDenObs.getAggregationResult());
        assertNull(femaleNumObs.getAggregationResult());
        assertNull(femaleDenObs.getAggregationResult());

        scorer.scoreGroup("http://example.com/Measure/rcv-stratum-agg", groupDef);

        // VERIFY: Stratum scores are correct
        assertEquals(2.0, maleStratum.getScore(), 0.001);
        assertEquals(3.0, femaleStratum.getScore(), 0.001);

        // VERIFY: Per-stratum aggregation results are persisted on StratumPopulationDef
        // Male: num_agg=40 (10+15+15), den_agg=20 (5+7+8)
        assertNotNull(maleNumObs.getAggregationResult(), "Male numerator stratum should have aggregation result");
        assertEquals(40.0, maleNumObs.getAggregationResult(), 0.001);
        assertNotNull(maleDenObs.getAggregationResult(), "Male denominator stratum should have aggregation result");
        assertEquals(20.0, maleDenObs.getAggregationResult(), 0.001);

        // Female: num_agg=30 (10+20), den_agg=10 (4+6)
        assertNotNull(femaleNumObs.getAggregationResult(), "Female numerator stratum should have aggregation result");
        assertEquals(30.0, femaleNumObs.getAggregationResult(), 0.001);
        assertNotNull(femaleDenObs.getAggregationResult(), "Female denominator stratum should have aggregation result");
        assertEquals(10.0, femaleDenObs.getAggregationResult(), 0.001);
    }

    @Test
    void testScoreStratifier_ContinuousVariable_PerStratumAggregationResults() {
        // Setup: CV measure with stratifier by gender
        // Male: observations 10, 20, 30  SUM = 60
        // Female: observations 5, 15  SUM = 20

        CodeDef booleanBasis = createBooleanBasisCode();
        PopulationDef initialPopulation = createPopulationDef(
                "ip-1", MeasurePopulationType.INITIALPOPULATION, Set.of("p1", "p2", "p3", "p4", "p5"), booleanBasis);
        PopulationDef measurePopulation = createPopulationDef(
                "mp-1", MeasurePopulationType.MEASUREPOPULATION, Set.of("p1", "p2", "p3", "p4", "p5"), booleanBasis);

        ConceptDef measureObsCode = createMeasurePopulationConcept(MeasurePopulationType.MEASUREOBSERVATION);
        PopulationDef measureObsPop = new PopulationDef(
                "msrobs-1",
                measureObsCode,
                MeasurePopulationType.MEASUREOBSERVATION,
                "expression",
                booleanBasis,
                null,
                ContinuousVariableObservationAggregateMethod.SUM,
                null);

        // Male observations: 10, 20, 30
        Map<String, QuantityDef> obs1 = new HashMap<>();
        obs1.put("obs-1", new QuantityDef(10.0));
        measureObsPop.addResource("p1", obs1);
        Map<String, QuantityDef> obs2 = new HashMap<>();
        obs2.put("obs-2", new QuantityDef(20.0));
        measureObsPop.addResource("p2", obs2);
        Map<String, QuantityDef> obs3 = new HashMap<>();
        obs3.put("obs-3", new QuantityDef(30.0));
        measureObsPop.addResource("p3", obs3);

        // Female observations: 5, 15
        Map<String, QuantityDef> obs4 = new HashMap<>();
        obs4.put("obs-4", new QuantityDef(5.0));
        measureObsPop.addResource("p4", obs4);
        Map<String, QuantityDef> obs5 = new HashMap<>();
        obs5.put("obs-5", new QuantityDef(15.0));
        measureObsPop.addResource("p5", obs5);

        // Male stratum
        StratumPopulationDef maleIpPop = new StratumPopulationDef(
                initialPopulation,
                Set.of("p1", "p2", "p3"),
                Set.of(),
                List.of(),
                MeasureStratifierType.VALUE,
                booleanBasis);
        StratumPopulationDef maleMpPop = new StratumPopulationDef(
                measurePopulation,
                Set.of("p1", "p2", "p3"),
                Set.of(),
                List.of(),
                MeasureStratifierType.VALUE,
                booleanBasis);
        StratumPopulationDef maleMsrObsPop = new StratumPopulationDef(
                measureObsPop,
                Set.of("p1", "p2", "p3"),
                Set.of(),
                List.of(),
                MeasureStratifierType.VALUE,
                booleanBasis);

        StratifierComponentDef genderComponent =
                new StratifierComponentDef("gender-component", createTextOnlyConcept("Gender"), "Gender");
        StratumDef maleStratum = new StratumDef(
                List.of(maleIpPop, maleMpPop, maleMsrObsPop),
                Set.of(new StratumValueDef(new StratumValueWrapper("male"), genderComponent)),
                Set.of("p1", "p2", "p3"),
                null);

        // Female stratum
        StratumPopulationDef femaleIpPop = new StratumPopulationDef(
                initialPopulation, Set.of("p4", "p5"), Set.of(), List.of(), MeasureStratifierType.VALUE, booleanBasis);
        StratumPopulationDef femaleMpPop = new StratumPopulationDef(
                measurePopulation, Set.of("p4", "p5"), Set.of(), List.of(), MeasureStratifierType.VALUE, booleanBasis);
        StratumPopulationDef femaleMsrObsPop = new StratumPopulationDef(
                measureObsPop, Set.of("p4", "p5"), Set.of(), List.of(), MeasureStratifierType.VALUE, booleanBasis);

        StratumDef femaleStratum = new StratumDef(
                List.of(femaleIpPop, femaleMpPop, femaleMsrObsPop),
                Set.of(new StratumValueDef(new StratumValueWrapper("female"), genderComponent)),
                Set.of("p4", "p5"),
                null);

        StratifierDef stratifierDef = new StratifierDef(
                "gender-stratifier", createTextOnlyConcept("Gender Stratifier"), "Gender", MeasureStratifierType.VALUE);
        stratifierDef.addAllStratum(List.of(maleStratum, femaleStratum));

        GroupDef groupDef = new GroupDef(
                "group-1",
                createTextOnlyConcept("CV Per-Stratum Aggregation Test"),
                List.of(stratifierDef),
                List.of(initialPopulation, measurePopulation, measureObsPop),
                MeasureScoring.CONTINUOUSVARIABLE,
                false,
                createImprovementNotationCode("increase"),
                booleanBasis);

        // Pre-scoring: no aggregation results
        assertNull(maleMsrObsPop.getAggregationResult());
        assertNull(femaleMsrObsPop.getAggregationResult());

        scorer.scoreGroup("http://example.com/Measure/cv-stratum-agg", groupDef);

        // VERIFY: Stratum scores
        assertEquals(60.0, maleStratum.getScore(), 0.001);
        assertEquals(20.0, femaleStratum.getScore(), 0.001);

        // VERIFY: Per-stratum aggregation results on MEASUREOBSERVATION StratumPopulationDef
        assertNotNull(maleMsrObsPop.getAggregationResult(), "Male CV stratum should have aggregation result");
        assertEquals(60.0, maleMsrObsPop.getAggregationResult(), 0.001);
        assertNotNull(femaleMsrObsPop.getAggregationResult(), "Female CV stratum should have aggregation result");
        assertEquals(20.0, femaleMsrObsPop.getAggregationResult(), 0.001);

        // VERIFY: Non-observation stratum populations should NOT have aggregation results
        assertNull(maleIpPop.getAggregationResult());
        assertNull(maleMpPop.getAggregationResult());
        assertNull(femaleIpPop.getAggregationResult());
        assertNull(femaleMpPop.getAggregationResult());
    }

    @Test
    void testScoreStratifier_Proportion_NoPerStratumAggregationResults() {
        // Verify that proportion stratifiers do NOT produce aggregation results on StratumPopulationDef
        CodeDef booleanBasis = createBooleanBasisCode();
        PopulationDef numeratorPop =
                createPopulationDef("num-1", MeasurePopulationType.NUMERATOR, Set.of("p1", "p2"), booleanBasis);
        PopulationDef denominatorPop =
                createPopulationDef("den-1", MeasurePopulationType.DENOMINATOR, Set.of("p1", "p2", "p3"), booleanBasis);

        StratumPopulationDef stratumNumPop = new StratumPopulationDef(
                numeratorPop, Set.of("p1"), Set.of(), List.of(), MeasureStratifierType.VALUE, booleanBasis);
        StratumPopulationDef stratumDenPop = new StratumPopulationDef(
                denominatorPop, Set.of("p1", "p2"), Set.of(), List.of(), MeasureStratifierType.VALUE, booleanBasis);

        StratifierComponentDef component = new StratifierComponentDef("comp-1", createTextOnlyConcept("Test"), "Test");
        StratumDef stratum = new StratumDef(
                List.of(stratumNumPop, stratumDenPop),
                Set.of(new StratumValueDef(new StratumValueWrapper("value1"), component)),
                Set.of("p1", "p2"),
                null);

        StratifierDef stratifierDef = new StratifierDef(
                "strat-1", createTextOnlyConcept("Test Stratifier"), "Test", MeasureStratifierType.VALUE);
        stratifierDef.addAllStratum(List.of(stratum));

        GroupDef groupDef = new GroupDef(
                "group-1",
                createTextOnlyConcept("Proportion - No Aggregation"),
                List.of(stratifierDef),
                List.of(numeratorPop, denominatorPop),
                MeasureScoring.PROPORTION,
                false,
                createImprovementNotationCode("increase"),
                booleanBasis);

        scorer.scoreGroup("http://example.com/Measure/proportion-no-agg", groupDef);

        // VERIFY: Proportion stratum populations should NOT have aggregation results
        assertNull(stratumNumPop.getAggregationResult());
        assertNull(stratumDenPop.getAggregationResult());

        // Score should still be set
        assertEquals(0.5, stratum.getScore(), 0.001);
    }

    // ============================================================================
    // Helper Methods for Test Data Construction
    // ============================================================================

    /**
     * Create PopulationDef with subjects and specified population basis.
     * The populationBasis CodeDef should be the SAME instance used for the GroupDef.
     */
    private PopulationDef createPopulationDef(
            String id, MeasurePopulationType type, Set<String> subjects, CodeDef populationBasis) {
        ConceptDef code = createMeasurePopulationConcept(type);
        PopulationDef pop = new PopulationDef(id, code, type, "expression", populationBasis, null);

        // Add subjects to population
        for (String subject : subjects) {
            pop.addResource(subject, true); // For boolean basis, resource is just boolean true
        }

        return pop;
    }

    /**
     * Create CodeDef for boolean population basis.
     */
    private CodeDef createBooleanBasisCode() {
        return new CodeDef("http://hl7.org/fhir/fhir-types", "boolean");
    }

    /**
     * Create CodeDef for measure-population system.
     */
    private CodeDef createMeasurePopulationCode(String code) {
        return new CodeDef("http://terminology.hl7.org/CodeSystem/measure-population", code);
    }

    /**
     * Create CodeDef for measure-improvement-notation system.
     */
    private CodeDef createImprovementNotationCode(String notation) {
        return new CodeDef("http://terminology.hl7.org/CodeSystem/measure-improvement-notation", notation);
    }

    /**
     * Create CodeDef for measure population basis.
     */
    private CodeDef createPopulationBasisCode(String basis) {
        return new CodeDef("http://hl7.org/fhir/ValueSet/measure-population", basis);
    }

    /**
     * Create ConceptDef for measure population type.
     */
    private ConceptDef createMeasurePopulationConcept(MeasurePopulationType type) {
        return new ConceptDef(List.of(createMeasurePopulationCode(type.toCode())), type.toCode());
    }

    /**
     * Create ConceptDef with text only (no codes).
     */
    private ConceptDef createTextOnlyConcept(String text) {
        return new ConceptDef(List.of(), text);
    }

    @Test
    void testScoreStratifier_QualifiedVsUnqualifiedSubjectIds() {
        // Setup: Group with stratifier where StratumPopulationDef uses qualified IDs
        // but PopulationDef.subjectResources uses unqualified IDs

        CodeDef booleanBasis = createBooleanBasisCode();

        // Create populations with UNQUALIFIED subject IDs
        PopulationDef numeratorPop = createPopulationDef(
                "num-1",
                MeasurePopulationType.NUMERATOR,
                Set.of("patient-1965-female", "patient-1966-female", "patient-1967-male"),
                booleanBasis);

        PopulationDef denominatorPop = createPopulationDef(
                "den-1",
                MeasurePopulationType.DENOMINATOR,
                Set.of("patient-1965-female", "patient-1966-female", "patient-1967-male", "patient-1968-male"),
                booleanBasis);

        // Create stratum populations with QUALIFIED subject IDs (e.g., "Patient/patient-1965-female")
        // Female stratum: 2 numerator / 2 denominator = 1.0
        StratumPopulationDef femaleNumPop = new StratumPopulationDef(
                numeratorPop,
                Set.of("Patient/patient-1965-female", "Patient/patient-1966-female"), // QUALIFIED IDs
                Set.of(),
                List.of(),
                MeasureStratifierType.VALUE,
                booleanBasis);

        StratumPopulationDef femaleDenPop = new StratumPopulationDef(
                denominatorPop,
                Set.of("Patient/patient-1965-female", "Patient/patient-1966-female"), // QUALIFIED IDs
                Set.of(),
                List.of(),
                MeasureStratifierType.VALUE,
                booleanBasis);

        StratifierComponentDef genderComponent =
                new StratifierComponentDef("gender-component", createTextOnlyConcept("Gender"), "Gender");

        StratumDef femaleStratum = new StratumDef(
                List.of(femaleNumPop, femaleDenPop),
                Set.of(new StratumValueDef(new StratumValueWrapper("female"), genderComponent)),
                Set.of("Patient/patient-1965-female", "Patient/patient-1966-female"), // QUALIFIED IDs
                null); // No MeasureObservationStratumCache needed for proportion measures

        // Male stratum: 1 numerator / 2 denominator = 0.5
        StratumPopulationDef maleNumPop = new StratumPopulationDef(
                numeratorPop,
                Set.of("Patient/patient-1967-male"), // QUALIFIED IDs
                Set.of(),
                List.of(),
                MeasureStratifierType.VALUE,
                booleanBasis);

        StratumPopulationDef maleDenPop = new StratumPopulationDef(
                denominatorPop,
                Set.of("Patient/patient-1967-male", "Patient/patient-1968-male"), // QUALIFIED IDs
                Set.of(),
                List.of(),
                MeasureStratifierType.VALUE,
                booleanBasis);

        StratumDef maleStratum = new StratumDef(
                List.of(maleNumPop, maleDenPop),
                Set.of(new StratumValueDef(new StratumValueWrapper("male"), genderComponent)),
                Set.of("Patient/patient-1967-male", "Patient/patient-1968-male"), // QUALIFIED IDs
                null); // No MeasureObservationStratumCache needed for proportion measures

        StratifierDef stratifierDef = new StratifierDef(
                "gender-stratifier", createTextOnlyConcept("Gender Stratifier"), "Gender", MeasureStratifierType.VALUE);
        stratifierDef.addAllStratum(List.of(femaleStratum, maleStratum));

        GroupDef groupDef = new GroupDef(
                "group-1",
                createTextOnlyConcept("Qualified vs Unqualified ID Test"),
                List.of(stratifierDef),
                List.of(numeratorPop, denominatorPop),
                MeasureScoring.PROPORTION,
                false,
                createImprovementNotationCode("increase"),
                booleanBasis);

        // Verify scores are null before scoring
        assertNull(femaleStratum.getScore());
        assertNull(maleStratum.getScore());

        // Execute
        scorer.scoreGroup("http://example.com/Measure/qualified-ids-test", groupDef);

        // VERIFY: aggregationResult is null (PROPORTION measure)
        assertNull(numeratorPop.getAggregationResult());
        assertNull(denominatorPop.getAggregationResult());

        // VERIFY: Scorer correctly matched qualified stratum IDs to unqualified population IDs
        // Female stratum: 2/2 = 1.0
        assertEquals(1.0, femaleStratum.getScore(), 0.001, "Female stratum should have score 1.0 (2/2)");

        // Male stratum: 1/2 = 0.5
        assertEquals(0.5, maleStratum.getScore(), 0.001, "Male stratum should have score 0.5 (1/2)");
    }

    // ============================================================================
    // PopulationDef.setAggregationResult() Tests
    // ============================================================================

    @Test
    void testPopulationDef_SetAggregationResultWithQuantityDef() {
        // Test the new setAggregationResult(QuantityDef) overload added in latest changes
        CodeDef booleanBasis = createBooleanBasisCode();
        ConceptDef measureObsCode = createMeasurePopulationConcept(MeasurePopulationType.MEASUREOBSERVATION);
        PopulationDef measureObsPop = new PopulationDef(
                "msrobs-1",
                measureObsCode,
                MeasurePopulationType.MEASUREOBSERVATION,
                "expression",
                booleanBasis,
                null,
                ContinuousVariableObservationAggregateMethod.SUM,
                null);

        // Initially null
        assertNull(measureObsPop.getAggregationResult());

        // Set using QuantityDef overload
        QuantityDef quantityDef = new QuantityDef(42.5);
        measureObsPop.setAggregationResult(quantityDef);

        // Verify value is extracted and set
        assertNotNull(measureObsPop.getAggregationResult());
        assertEquals(42.5, measureObsPop.getAggregationResult(), 0.001);
    }

    @Test
    void testPopulationDef_SetAggregationResultWithNullQuantityDef() {
        // Test the setAggregationResult(QuantityDef) overload with null
        CodeDef booleanBasis = createBooleanBasisCode();
        ConceptDef measureObsCode = createMeasurePopulationConcept(MeasurePopulationType.MEASUREOBSERVATION);
        PopulationDef measureObsPop = new PopulationDef(
                "msrobs-1",
                measureObsCode,
                MeasurePopulationType.MEASUREOBSERVATION,
                "expression",
                booleanBasis,
                null,
                ContinuousVariableObservationAggregateMethod.AVG,
                null);

        // Set to a value first
        measureObsPop.setAggregationResult(100.0);
        assertEquals(100.0, measureObsPop.getAggregationResult(), 0.001);

        // Set to null using QuantityDef overload
        measureObsPop.setAggregationResult((QuantityDef) null);

        // Verify it's null
        assertNull(measureObsPop.getAggregationResult());
    }

    @Test
    void testPopulationDef_SetAggregationResultWithDouble() {
        // Test the existing setAggregationResult(Double) method still works
        CodeDef booleanBasis = createBooleanBasisCode();
        ConceptDef measureObsCode = createMeasurePopulationConcept(MeasurePopulationType.MEASUREOBSERVATION);
        PopulationDef measureObsPop = new PopulationDef(
                "msrobs-1",
                measureObsCode,
                MeasurePopulationType.MEASUREOBSERVATION,
                "expression",
                booleanBasis,
                null,
                ContinuousVariableObservationAggregateMethod.MEDIAN,
                null);

        // Initially null
        assertNull(measureObsPop.getAggregationResult());

        // Set using Double
        measureObsPop.setAggregationResult(99.9);

        // Verify value is set
        assertNotNull(measureObsPop.getAggregationResult());
        assertEquals(99.9, measureObsPop.getAggregationResult(), 0.001);

        // Can also set to null
        measureObsPop.setAggregationResult((Double) null);
        assertNull(measureObsPop.getAggregationResult());
    }

    @Test
    void testScoreGroup_ContinuousVariable_MedianAggregation() {
        // Test MEDIAN aggregation and verify aggregationResult is set
        // Observations: 5.0, 10.0, 15.0, 20.0, 25.0  MEDIAN = 15.0
        CodeDef booleanBasis = createBooleanBasisCode();
        PopulationDef initialPopulation = createPopulationDef(
                "ip-1", MeasurePopulationType.INITIALPOPULATION, Set.of("p1", "p2", "p3", "p4", "p5"), booleanBasis);

        PopulationDef measurePopulation = createPopulationDef(
                "mp-1", MeasurePopulationType.MEASUREPOPULATION, Set.of("p1", "p2", "p3", "p4", "p5"), booleanBasis);

        ConceptDef measureObsCode = createMeasurePopulationConcept(MeasurePopulationType.MEASUREOBSERVATION);
        PopulationDef measureObsPop = new PopulationDef(
                "msrobs-1",
                measureObsCode,
                MeasurePopulationType.MEASUREOBSERVATION,
                "expression",
                booleanBasis,
                null,
                ContinuousVariableObservationAggregateMethod.MEDIAN,
                null);

        // Add observations in non-sorted order
        Map<String, QuantityDef> obs1 = new HashMap<>();
        obs1.put("obs-1", new QuantityDef(20.0));
        measureObsPop.addResource("p1", obs1);

        Map<String, QuantityDef> obs2 = new HashMap<>();
        obs2.put("obs-2", new QuantityDef(5.0));
        measureObsPop.addResource("p2", obs2);

        Map<String, QuantityDef> obs3 = new HashMap<>();
        obs3.put("obs-3", new QuantityDef(25.0));
        measureObsPop.addResource("p3", obs3);

        Map<String, QuantityDef> obs4 = new HashMap<>();
        obs4.put("obs-4", new QuantityDef(10.0));
        measureObsPop.addResource("p4", obs4);

        Map<String, QuantityDef> obs5 = new HashMap<>();
        obs5.put("obs-5", new QuantityDef(15.0));
        measureObsPop.addResource("p5", obs5);

        GroupDef groupDef = new GroupDef(
                "group-1",
                createTextOnlyConcept("Test MEDIAN Aggregation"),
                List.of(),
                List.of(initialPopulation, measurePopulation, measureObsPop),
                MeasureScoring.CONTINUOUSVARIABLE,
                false,
                createImprovementNotationCode("increase"),
                booleanBasis);

        assertNull(groupDef.getScore());
        assertNull(measureObsPop.getAggregationResult());

        scorer.scoreGroup("http://example.com/Measure/median-test", groupDef);

        // VERIFY: aggregationResult is null for non-observation populations
        assertNull(initialPopulation.getAggregationResult());
        assertNull(measurePopulation.getAggregationResult());

        // VERIFY: aggregationResult IS set for MEASUREOBSERVATION population (stores MEDIAN result)
        assertNotNull(measureObsPop.getAggregationResult());
        assertEquals(15.0, measureObsPop.getAggregationResult(), 0.001);

        // VERIFY: MEDIAN aggregation = 15.0
        assertEquals(15.0, groupDef.getScore(), 0.001);
    }

    @Test
    void testScoreGroup_ContinuousVariable_CountAggregation() {
        // Test COUNT aggregation and verify aggregationResult is set
        // 7 observations  COUNT = 7.0
        CodeDef encounterBasis = createPopulationBasisCode("Encounter");
        PopulationDef initialPopulation = createPopulationDef(
                "ip-1", MeasurePopulationType.INITIALPOPULATION, Set.of("p1", "p2"), encounterBasis);

        PopulationDef measurePopulation = createPopulationDef(
                "mp-1", MeasurePopulationType.MEASUREPOPULATION, Set.of("p1", "p2"), encounterBasis);

        ConceptDef measureObsCode = createMeasurePopulationConcept(MeasurePopulationType.MEASUREOBSERVATION);
        PopulationDef measureObsPop = new PopulationDef(
                "msrobs-1",
                measureObsCode,
                MeasurePopulationType.MEASUREOBSERVATION,
                "expression",
                encounterBasis,
                null,
                ContinuousVariableObservationAggregateMethod.COUNT,
                null);

        // Patient 1 has 4 observations
        Map<String, QuantityDef> obs1 = new HashMap<>();
        obs1.put("obs-1", new QuantityDef(10.0));
        obs1.put("obs-2", new QuantityDef(20.0));
        obs1.put("obs-3", new QuantityDef(30.0));
        obs1.put("obs-4", new QuantityDef(40.0));
        measureObsPop.addResource("p1", obs1);

        // Patient 2 has 3 observations
        Map<String, QuantityDef> obs2 = new HashMap<>();
        obs2.put("obs-5", new QuantityDef(50.0));
        obs2.put("obs-6", new QuantityDef(60.0));
        obs2.put("obs-7", new QuantityDef(70.0));
        measureObsPop.addResource("p2", obs2);

        GroupDef groupDef = new GroupDef(
                "group-1",
                createTextOnlyConcept("Test COUNT Aggregation"),
                List.of(),
                List.of(initialPopulation, measurePopulation, measureObsPop),
                MeasureScoring.CONTINUOUSVARIABLE,
                false,
                createImprovementNotationCode("increase"),
                encounterBasis);

        assertNull(groupDef.getScore());
        assertNull(measureObsPop.getAggregationResult());

        scorer.scoreGroup("http://example.com/Measure/count-test", groupDef);

        // VERIFY: aggregationResult is null for non-observation populations
        assertNull(initialPopulation.getAggregationResult());
        assertNull(measurePopulation.getAggregationResult());

        // VERIFY: aggregationResult IS set for MEASUREOBSERVATION population (stores COUNT result)
        assertNotNull(measureObsPop.getAggregationResult());
        assertEquals(7.0, measureObsPop.getAggregationResult(), 0.001);

        // VERIFY: COUNT aggregation = 7.0
        assertEquals(7.0, groupDef.getScore(), 0.001);
    }
}
