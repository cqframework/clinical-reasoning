package org.opencds.cqf.fhir.cr.measure.common;

import static org.junit.jupiter.api.Assertions.*;

import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import org.junit.jupiter.api.Test;
import org.opencds.cqf.fhir.cr.measure.MeasureStratifierType;

/**
 * Comprehensive unit tests for version-agnostic MeasureDefScorer.
 *
 * Tests the Def-first iteration pattern AND mutation-based design where
 * scores are set directly on Def objects using setScore() methods.
 *
 * All tests use constructors to create Def objects (NO MOCKS).
 *
 * Generated by Claude Sonnet 4.5 on 2025-12-03
 */
class MeasureDefScorerTest {

    @Test
    void testScoreGroup_SetsScoreOnGroupDef() {
        // Setup: Simple proportion measure with 3/4 subjects meeting criteria
        PopulationDef numeratorPop = createPopulationDef(
                "num-1", MeasurePopulationType.NUMERATOR, Set.of("patient1", "patient2", "patient3"));
        PopulationDef denominatorPop = createPopulationDef(
                "den-1", MeasurePopulationType.DENOMINATOR, Set.of("patient1", "patient2", "patient3", "patient4"));

        GroupDef groupDef = new GroupDef(
                "group-1",
                createTextOnlyConcept("Test Group"),
                List.of(), // No stratifiers
                List.of(numeratorPop, denominatorPop),
                MeasureScoring.PROPORTION,
                false,
                createImprovementNotationCode("increase"),
                createPopulationBasisCode("Encounter"));

        // Score is null before scoring
        assertNull(groupDef.getScore());

        MeasureDefScorer scorer = new MeasureDefScorer();
        scorer.scoreGroup("http://example.com/Measure/test", groupDef);

        // VERIFY: Score is set on GroupDef via mutation
        assertEquals(0.75, groupDef.getScore(), 0.001);
        // VERIFY: getMeasureScore returns score as-is for increase notation
        assertEquals(0.75, groupDef.getMeasureScore(), 0.001);
    }

    @Test
    void testScoreGroup_ProportionWithExclusions() {
        // Setup: Proportion measure with exclusions and exceptions
        // Formula: (n - nx) / (d - dx - de)
        // (10 - 2) / (20 - 3 - 1) = 8 / 16 = 0.5
        PopulationDef numeratorPop = createPopulationDef(
                "num-1",
                MeasurePopulationType.NUMERATOR,
                Set.of("p1", "p2", "p3", "p4", "p5", "p6", "p7", "p8", "p9", "p10"));
        PopulationDef denominatorPop = createPopulationDef(
                "den-1",
                MeasurePopulationType.DENOMINATOR,
                Set.of(
                        "p1", "p2", "p3", "p4", "p5", "p6", "p7", "p8", "p9", "p10", "p11", "p12", "p13", "p14", "p15",
                        "p16", "p17", "p18", "p19", "p20"));
        PopulationDef denExclusionPop =
                createPopulationDef("dex-1", MeasurePopulationType.DENOMINATOREXCLUSION, Set.of("p11", "p12", "p13"));
        PopulationDef denExceptionPop =
                createPopulationDef("dexc-1", MeasurePopulationType.DENOMINATOREXCEPTION, Set.of("p14"));
        PopulationDef numExclusionPop =
                createPopulationDef("nex-1", MeasurePopulationType.NUMERATOREXCLUSION, Set.of("p1", "p2"));

        GroupDef groupDef = new GroupDef(
                "group-1",
                createTextOnlyConcept("Test Group"),
                List.of(),
                List.of(numeratorPop, denominatorPop, denExclusionPop, denExceptionPop, numExclusionPop),
                MeasureScoring.PROPORTION,
                false,
                createImprovementNotationCode("increase"),
                createPopulationBasisCode("String"));

        MeasureDefScorer scorer = new MeasureDefScorer();
        scorer.scoreGroup("http://example.com/Measure/test", groupDef);

        // VERIFY: Score is set correctly
        assertEquals(0.5, groupDef.getScore(), 0.001);
    }

    @Test
    void testScoreGroup_ZeroDenominator_SetsNullScore() {
        // Setup: All subjects excluded from denominator
        PopulationDef numeratorPop =
                createPopulationDef("num-1", MeasurePopulationType.NUMERATOR, Set.of("p1", "p2", "p3", "p4", "p5"));
        PopulationDef denominatorPop = createPopulationDef(
                "den-1",
                MeasurePopulationType.DENOMINATOR,
                Set.of("p1", "p2", "p3", "p4", "p5", "p6", "p7", "p8", "p9", "p10"));
        PopulationDef denExclusionPop = createPopulationDef(
                "dex-1",
                MeasurePopulationType.DENOMINATOREXCLUSION,
                Set.of("p1", "p2", "p3", "p4", "p5", "p6", "p7", "p8", "p9", "p10")); // All excluded

        GroupDef groupDef = new GroupDef(
                "group-1",
                createTextOnlyConcept("Test Group"),
                List.of(),
                List.of(numeratorPop, denominatorPop, denExclusionPop),
                MeasureScoring.PROPORTION,
                false,
                createImprovementNotationCode("increase"),
                createPopulationBasisCode("date"));

        MeasureDefScorer scorer = new MeasureDefScorer();
        scorer.scoreGroup("http://example.com/Measure/test", groupDef);

        // VERIFY: Null score set for zero denominator
        assertNull(groupDef.getScore());
    }

    @Test
    void testScoreStratifier_SetsScoresOnStratumDefs() {
        // Setup: Group with stratifier containing two strata
        // Male stratum: 3/5 = 0.6
        // Female stratum: 5/5 = 1.0

        PopulationDef numeratorPop = createPopulationDef(
                "num-1",
                MeasurePopulationType.NUMERATOR,
                Set.of("male1", "male2", "male3", "female1", "female2", "female3", "female4", "female5"));
        PopulationDef denominatorPop = createPopulationDef(
                "den-1",
                MeasurePopulationType.DENOMINATOR,
                Set.of(
                        "male1", "male2", "male3", "male4", "male5", "female1", "female2", "female3", "female4",
                        "female5"));

        // Create stratum populations for Male stratum
        CodeDef booleanBasisCode = createPopulationBasisCode("boolean");

        StratumPopulationDef maleNumPop = new StratumPopulationDef(
                "num-1",
                Set.of("male1", "male2", "male3"),
                Set.of(),
                List.of(),
                MeasureStratifierType.VALUE,
                booleanBasisCode);
        StratumPopulationDef maleDenPop = new StratumPopulationDef(
                "den-1",
                Set.of("male1", "male2", "male3", "male4", "male5"),
                Set.of(),
                List.of(),
                MeasureStratifierType.VALUE,
                booleanBasisCode);

        StratifierComponentDef genderComponent =
                new StratifierComponentDef("gender-component", createTextOnlyConcept("Gender"), "Gender");
        StratumDef maleStratum = new StratumDef(
                List.of(maleNumPop, maleDenPop),
                Set.of(new StratumValueDef(new StratumValueWrapper("male"), genderComponent)),
                Set.of("male1", "male2", "male3", "male4", "male5"));

        // Create stratum populations for Female stratum
        StratumPopulationDef femaleNumPop = new StratumPopulationDef(
                "num-1",
                Set.of("female1", "female2", "female3", "female4", "female5"),
                Set.of(),
                List.of(),
                MeasureStratifierType.VALUE,
                booleanBasisCode);
        StratumPopulationDef femaleDenPop = new StratumPopulationDef(
                "den-1",
                Set.of("female1", "female2", "female3", "female4", "female5"),
                Set.of(),
                List.of(),
                MeasureStratifierType.VALUE,
                booleanBasisCode);

        StratumDef femaleStratum = new StratumDef(
                List.of(femaleNumPop, femaleDenPop),
                Set.of(new StratumValueDef(new StratumValueWrapper("female"), genderComponent)),
                Set.of("female1", "female2", "female3", "female4", "female5"));

        StratifierDef stratifierDef = new StratifierDef(
                "gender-stratifier", createTextOnlyConcept("Gender Stratifier"), "Gender", MeasureStratifierType.VALUE);
        stratifierDef.addAllStratum(List.of(maleStratum, femaleStratum));

        GroupDef groupDef = new GroupDef(
                "group-1",
                createTextOnlyConcept("Test Group"),
                List.of(stratifierDef),
                List.of(numeratorPop, denominatorPop),
                MeasureScoring.PROPORTION,
                false,
                createImprovementNotationCode("increase"),
                booleanBasisCode);

        // Scores are null before scoring
        assertNull(maleStratum.getScore());
        assertNull(femaleStratum.getScore());

        // Execute
        MeasureDefScorer scorer = new MeasureDefScorer();
        scorer.scoreGroup("http://example.com/Measure/test", groupDef);

        // VERIFY: Scores are set on each StratumDef via mutation
        assertEquals(0.6, maleStratum.getScore(), 0.001); // Male: 3/5
        assertEquals(1.0, femaleStratum.getScore(), 0.001); // Female: 5/5
    }

    @Test
    void testScoreGroup_RatioMeasure() {
        // Setup: Ratio measure with 6/12 = 0.5
        PopulationDef numeratorPop = createPopulationDef(
                "num-1", MeasurePopulationType.NUMERATOR, Set.of("p1", "p2", "p3", "p4", "p5", "p6"));
        PopulationDef denominatorPop = createPopulationDef(
                "den-1",
                MeasurePopulationType.DENOMINATOR,
                Set.of("p1", "p2", "p3", "p4", "p5", "p6", "p7", "p8", "p9", "p10", "p11", "p12"));

        GroupDef groupDef = new GroupDef(
                "group-1",
                createTextOnlyConcept("Test Group"),
                List.of(),
                List.of(numeratorPop, denominatorPop),
                MeasureScoring.RATIO,
                false,
                createImprovementNotationCode("increase"),
                createPopulationBasisCode("String"));

        assertNull(groupDef.getScore());

        MeasureDefScorer scorer = new MeasureDefScorer();
        scorer.scoreGroup("http://example.com/Measure/test", groupDef);

        assertEquals(0.5, groupDef.getScore(), 0.001);
    }

    @Test
    void testScoreGroup_ContinuousVariable_SumAggregation() {
        // Setup: Continuous variable measure with SUM aggregation
        // Subject observations: 10.0, 20.0, 30.0 = 60.0 total
        PopulationDef initialPopulation =
                createPopulationDef("ip-1", MeasurePopulationType.INITIALPOPULATION, Set.of("p1", "p2", "p3"));

        PopulationDef measurePopulation =
                createPopulationDef("mp-1", MeasurePopulationType.MEASUREPOPULATION, Set.of("p1", "p2", "p3"));

        // Create MEASUREOBSERVATION population with QuantityDef observations
        // Default aggregation method is SUM when not specified
        ConceptDef measureObsCode = createMeasurePopulationConcept(MeasurePopulationType.MEASUREOBSERVATION);
        PopulationDef measureObsPop = new PopulationDef(
                "msrobs-1",
                measureObsCode,
                MeasurePopulationType.MEASUREOBSERVATION,
                "expression",
                null,
                ContinuousVariableObservationAggregateMethod.SUM);

        // Add QuantityDef observations for each subject
        Map<String, QuantityDef> obs1 = new HashMap<>();
        obs1.put("obs-1", new QuantityDef(10.0));
        measureObsPop.addResource("p1", obs1);

        Map<String, QuantityDef> obs2 = new HashMap<>();
        obs2.put("obs-2", new QuantityDef(20.0));
        measureObsPop.addResource("p2", obs2);

        Map<String, QuantityDef> obs3 = new HashMap<>();
        obs3.put("obs-3", new QuantityDef(30.0));
        measureObsPop.addResource("p3", obs3);

        GroupDef groupDef = new GroupDef(
                "group-1",
                createTextOnlyConcept("Test Group"),
                List.of(),
                List.of(initialPopulation, measurePopulation, measureObsPop),
                MeasureScoring.CONTINUOUSVARIABLE,
                false,
                createImprovementNotationCode("increase"),
                createPopulationBasisCode("date"));

        assertNull(groupDef.getScore());

        MeasureDefScorer scorer = new MeasureDefScorer();
        scorer.scoreGroup("http://example.com/Measure/test", groupDef);

        // VERIFY: SUM aggregation = 60.0
        assertEquals(60.0, groupDef.getScore(), 0.001);
    }

    @Test
    void testScoreGroup_ContinuousVariable_AvgAggregation() {
        // Setup: Continuous variable measure with AVG aggregation
        // Subject observations: 10.0, 20.0, 30.0 = 20.0 average
        PopulationDef initialPopulation =
                createPopulationDef("ip-1", MeasurePopulationType.INITIALPOPULATION, Set.of("p1", "p2", "p3"));

        PopulationDef measurePopulation =
                createPopulationDef("mp-1", MeasurePopulationType.MEASUREPOPULATION, Set.of("p1", "p2", "p3"));

        ConceptDef measureObsCode = createMeasurePopulationConcept(MeasurePopulationType.MEASUREOBSERVATION);
        PopulationDef measureObsPop = new PopulationDef(
                "msrobs-1",
                measureObsCode,
                MeasurePopulationType.MEASUREOBSERVATION,
                "expression",
                null,
                ContinuousVariableObservationAggregateMethod.AVG);

        Map<String, QuantityDef> obs1 = new HashMap<>();
        obs1.put("obs-1", new QuantityDef(10.0));
        measureObsPop.addResource("p1", obs1);

        Map<String, QuantityDef> obs2 = new HashMap<>();
        obs2.put("obs-2", new QuantityDef(20.0));
        measureObsPop.addResource("p2", obs2);

        Map<String, QuantityDef> obs3 = new HashMap<>();
        obs3.put("obs-3", new QuantityDef(30.0));
        measureObsPop.addResource("p3", obs3);

        GroupDef groupDef = new GroupDef(
                "group-1",
                createTextOnlyConcept("Test Group"),
                List.of(),
                List.of(initialPopulation, measurePopulation, measureObsPop),
                MeasureScoring.CONTINUOUSVARIABLE,
                false,
                createImprovementNotationCode("increase"),
                createPopulationBasisCode("boolean"));

        assertNull(groupDef.getScore());

        MeasureDefScorer scorer = new MeasureDefScorer();
        scorer.scoreGroup("http://example.com/Measure/test", groupDef);

        // VERIFY: AVG aggregation = 20.0
        assertEquals(20.0, groupDef.getScore(), 0.001);
    }

    @Test
    void testScoreGroup_ContinuousVariable_MinAggregation() {
        // Setup: Continuous variable with MIN aggregation
        // Subject observations: 10.0, 20.0, 30.0 = 10.0 min
        PopulationDef initialPopulation =
                createPopulationDef("ip-1", MeasurePopulationType.INITIALPOPULATION, Set.of("p1", "p2", "p3"));

        PopulationDef measurePopulation =
                createPopulationDef("mp-1", MeasurePopulationType.MEASUREPOPULATION, Set.of("p1", "p2", "p3"));

        ConceptDef measureObsCode = createMeasurePopulationConcept(MeasurePopulationType.MEASUREOBSERVATION);
        PopulationDef measureObsPop = new PopulationDef(
                "msrobs-1",
                measureObsCode,
                MeasurePopulationType.MEASUREOBSERVATION,
                "expression",
                null,
                ContinuousVariableObservationAggregateMethod.MIN);

        Map<String, QuantityDef> obs1 = new HashMap<>();
        obs1.put("obs-1", new QuantityDef(10.0));
        measureObsPop.addResource("p1", obs1);

        Map<String, QuantityDef> obs2 = new HashMap<>();
        obs2.put("obs-2", new QuantityDef(20.0));
        measureObsPop.addResource("p2", obs2);

        Map<String, QuantityDef> obs3 = new HashMap<>();
        obs3.put("obs-3", new QuantityDef(30.0));
        measureObsPop.addResource("p3", obs3);

        GroupDef groupDef = new GroupDef(
                "group-1",
                createTextOnlyConcept("Test Group"),
                List.of(),
                List.of(initialPopulation, measurePopulation, measureObsPop),
                MeasureScoring.CONTINUOUSVARIABLE,
                false,
                createImprovementNotationCode("increase"),
                createPopulationBasisCode("Encounter"));

        assertNull(groupDef.getScore());

        MeasureDefScorer scorer = new MeasureDefScorer();
        scorer.scoreGroup("http://example.com/Measure/test", groupDef);

        // VERIFY: MIN aggregation = 10.0
        assertEquals(10.0, groupDef.getScore(), 0.001);
    }

    @Test
    void testScoreGroup_ContinuousVariable_MaxAggregation() {
        // Setup: Continuous variable with MAX aggregation
        // Subject observations: 10.0, 20.0, 30.0 = 30.0 max
        PopulationDef initialPopulation =
                createPopulationDef("ip-1", MeasurePopulationType.INITIALPOPULATION, Set.of("p1", "p2", "p3"));

        PopulationDef measurePopulation =
                createPopulationDef("mp-1", MeasurePopulationType.MEASUREPOPULATION, Set.of("p1", "p2", "p3"));

        ConceptDef measureObsCode = createMeasurePopulationConcept(MeasurePopulationType.MEASUREOBSERVATION);
        PopulationDef measureObsPop = new PopulationDef(
                "msrobs-1",
                measureObsCode,
                MeasurePopulationType.MEASUREOBSERVATION,
                "expression",
                null,
                ContinuousVariableObservationAggregateMethod.MAX);

        Map<String, QuantityDef> obs1 = new HashMap<>();
        obs1.put("obs-1", new QuantityDef(10.0));
        measureObsPop.addResource("p1", obs1);

        Map<String, QuantityDef> obs2 = new HashMap<>();
        obs2.put("obs-2", new QuantityDef(20.0));
        measureObsPop.addResource("p2", obs2);

        Map<String, QuantityDef> obs3 = new HashMap<>();
        obs3.put("obs-3", new QuantityDef(30.0));
        measureObsPop.addResource("p3", obs3);

        GroupDef groupDef = new GroupDef(
                "group-1",
                createTextOnlyConcept("Test Group"),
                List.of(),
                List.of(initialPopulation, measurePopulation, measureObsPop),
                MeasureScoring.CONTINUOUSVARIABLE,
                false,
                createImprovementNotationCode("increase"),
                createPopulationBasisCode("String"));

        assertNull(groupDef.getScore());

        MeasureDefScorer scorer = new MeasureDefScorer();
        scorer.scoreGroup("http://example.com/Measure/test", groupDef);

        // VERIFY: MAX aggregation = 30.0
        assertEquals(30.0, groupDef.getScore(), 0.001);
    }

    // ============================================================================
    // GroupDef.getMeasureScore() Tests - Improvement Notation Adjustment
    // ============================================================================

    @Test
    void testGetMeasureScore_NullScore() {
        // Setup: Group with no scoring performed (score is null)
        PopulationDef numeratorPop = createPopulationDef(
                "num-1", MeasurePopulationType.NUMERATOR, Set.of("patient1", "patient2", "patient3"));
        PopulationDef denominatorPop = createPopulationDef(
                "den-1", MeasurePopulationType.DENOMINATOR, Set.of("patient1", "patient2", "patient3", "patient4"));

        GroupDef groupDef = new GroupDef(
                "group-1",
                createTextOnlyConcept("Test Group"),
                List.of(),
                List.of(numeratorPop, denominatorPop),
                MeasureScoring.PROPORTION,
                false,
                createImprovementNotationCode("increase"),
                createPopulationBasisCode("date"));

        // VERIFY: getMeasureScore returns null when score is null
        assertNull(groupDef.getScore());
        assertNull(groupDef.getMeasureScore());
    }

    @Test
    void testGetMeasureScore_ZeroScore_IncreaseNotation() {
        // Setup: Group with zero score and increase notation
        PopulationDef numeratorPop =
                createPopulationDef("num-1", MeasurePopulationType.NUMERATOR, Set.of()); // No subjects
        PopulationDef denominatorPop = createPopulationDef(
                "den-1", MeasurePopulationType.DENOMINATOR, Set.of("patient1", "patient2", "patient3", "patient4"));

        GroupDef groupDef = new GroupDef(
                "group-1",
                createTextOnlyConcept("Test Group"),
                List.of(),
                List.of(numeratorPop, denominatorPop),
                MeasureScoring.PROPORTION,
                false,
                createImprovementNotationCode("increase"),
                createPopulationBasisCode("Encounter"));

        MeasureDefScorer scorer = new MeasureDefScorer();
        scorer.scoreGroup("http://example.com/Measure/test", groupDef);

        // VERIFY: Score is 0/4 = 0.0
        assertEquals(0.0, groupDef.getScore(), 0.001);
        // VERIFY: getMeasureScore returns 0.0 for increase notation
        assertEquals(0.0, groupDef.getMeasureScore(), 0.001);
    }

    @Test
    void testGetMeasureScore_NegativeScore_ReturnsNull() {
        // Setup: Group with manually set negative score (simulating applySetMembership=false scenario)
        PopulationDef numeratorPop = createPopulationDef(
                "num-1", MeasurePopulationType.NUMERATOR, Set.of("patient1", "patient2", "patient3"));
        PopulationDef denominatorPop = createPopulationDef(
                "den-1", MeasurePopulationType.DENOMINATOR, Set.of("patient1", "patient2", "patient3", "patient4"));

        GroupDef groupDef = new GroupDef(
                "group-1",
                createTextOnlyConcept("Test Group"),
                List.of(),
                List.of(numeratorPop, denominatorPop),
                MeasureScoring.PROPORTION,
                false,
                createImprovementNotationCode("increase"),
                createPopulationBasisCode("String"));

        // Manually set negative score to simulate strange value scenario
        groupDef.setScore(-0.5);

        // VERIFY: getScore returns the negative value
        assertEquals(-0.5, groupDef.getScore(), 0.001);
        // VERIFY: getMeasureScore returns null for negative scores
        assertNull(groupDef.getMeasureScore());
    }

    @Test
    void testGetMeasureScore_PositiveScore_IncreaseNotation() {
        // Setup: Group with positive score and increase notation
        PopulationDef numeratorPop = createPopulationDef(
                "num-1", MeasurePopulationType.NUMERATOR, Set.of("patient1", "patient2", "patient3"));
        PopulationDef denominatorPop = createPopulationDef(
                "den-1", MeasurePopulationType.DENOMINATOR, Set.of("patient1", "patient2", "patient3", "patient4"));

        GroupDef groupDef = new GroupDef(
                "group-1",
                createTextOnlyConcept("Test Group"),
                List.of(),
                List.of(numeratorPop, denominatorPop),
                MeasureScoring.PROPORTION,
                false,
                createImprovementNotationCode("increase"),
                createPopulationBasisCode("date"));

        MeasureDefScorer scorer = new MeasureDefScorer();
        scorer.scoreGroup("http://example.com/Measure/test", groupDef);

        // VERIFY: Score is 3/4 = 0.75
        assertEquals(0.75, groupDef.getScore(), 0.001);
        // VERIFY: getMeasureScore returns score as-is for increase notation
        assertEquals(0.75, groupDef.getMeasureScore(), 0.001);
    }

    @Test
    void testGetMeasureScore_PositiveScore_DecreaseNotation() {
        // Setup: Group with positive score and decrease notation
        PopulationDef numeratorPop = createPopulationDef(
                "num-1", MeasurePopulationType.NUMERATOR, Set.of("patient1", "patient2", "patient3"));
        PopulationDef denominatorPop = createPopulationDef(
                "den-1", MeasurePopulationType.DENOMINATOR, Set.of("patient1", "patient2", "patient3", "patient4"));

        GroupDef groupDef = new GroupDef(
                "group-1",
                createTextOnlyConcept("Test Group"),
                List.of(),
                List.of(numeratorPop, denominatorPop),
                MeasureScoring.PROPORTION,
                false,
                createImprovementNotationCode("decrease"), // DECREASE notation
                createPopulationBasisCode("boolean"));

        MeasureDefScorer scorer = new MeasureDefScorer();
        scorer.scoreGroup("http://example.com/Measure/test", groupDef);

        // VERIFY: Score is 3/4 = 0.75
        assertEquals(0.75, groupDef.getScore(), 0.001);
        // VERIFY: getMeasureScore returns (1 - score) = 0.25 for decrease notation
        assertEquals(0.25, groupDef.getMeasureScore(), 0.001);
    }

    // ============================================================================
    // Population Basis Tests - Boolean vs Non-Boolean Counting
    // ============================================================================

    /**
     * Test that demonstrates population basis "boolean" counts unique subjects.
     * <p>
     * With boolean basis, PopulationDef.getCount() calls getSubjects().size().
     * Even if a subject has multiple resources, they are counted only once.
     * <p>
     * This test has:
     * - Numerator: 2 subjects (patient1 with 3 encounters, patient2 with 2 encounters)
     * - Denominator: 3 subjects (patient1, patient2, patient3 each with multiple encounters)
     * - Expected score: 2 subjects / 3 subjects = 0.667
     */
    @Test
    void testScoreGroup_BooleanBasis_CountsUniqueSubjects() {
        // Create numerator with 2 subjects, each having multiple resources
        ConceptDef numeratorCode = createMeasurePopulationConcept(MeasurePopulationType.NUMERATOR);
        PopulationDef numeratorPop =
                new PopulationDef("num-1", numeratorCode, MeasurePopulationType.NUMERATOR, "Numerator");

        // Patient1: 3 encounters in numerator
        numeratorPop.addResource("patient1", "Encounter/enc1");
        numeratorPop.addResource("patient1", "Encounter/enc2");
        numeratorPop.addResource("patient1", "Encounter/enc3");

        // Patient2: 2 encounters in numerator
        numeratorPop.addResource("patient2", "Encounter/enc4");
        numeratorPop.addResource("patient2", "Encounter/enc5");

        // Create denominator with 3 subjects, each having multiple resources
        ConceptDef denominatorCode = createMeasurePopulationConcept(MeasurePopulationType.DENOMINATOR);
        PopulationDef denominatorPop =
                new PopulationDef("den-1", denominatorCode, MeasurePopulationType.DENOMINATOR, "Denominator");

        // Patient1: 3 encounters in denominator
        denominatorPop.addResource("patient1", "Encounter/enc1");
        denominatorPop.addResource("patient1", "Encounter/enc2");
        denominatorPop.addResource("patient1", "Encounter/enc3");

        // Patient2: 2 encounters in denominator
        denominatorPop.addResource("patient2", "Encounter/enc4");
        denominatorPop.addResource("patient2", "Encounter/enc5");

        // Patient3: 4 encounters in denominator (NOT in numerator)
        denominatorPop.addResource("patient3", "Encounter/enc6");
        denominatorPop.addResource("patient3", "Encounter/enc7");
        denominatorPop.addResource("patient3", "Encounter/enc8");
        denominatorPop.addResource("patient3", "Encounter/enc9");

        // CRITICAL: Use boolean basis
        GroupDef groupDef = new GroupDef(
                "group-1",
                createTextOnlyConcept("Boolean Basis Test"),
                List.of(),
                List.of(numeratorPop, denominatorPop),
                MeasureScoring.PROPORTION,
                false,
                createImprovementNotationCode("increase"),
                createPopulationBasisCode("boolean"));

        // Verify counts BEFORE scoring
        // Boolean basis: count unique subjects, NOT resources
        assertEquals(2, numeratorPop.getCount(groupDef)); // 2 subjects (patient1, patient2)
        assertEquals(3, denominatorPop.getCount(groupDef)); // 3 subjects (patient1, patient2, patient3)

        // Execute scoring
        MeasureDefScorer scorer = new MeasureDefScorer();
        scorer.scoreGroup("http://example.com/Measure/test", groupDef);

        // VERIFY: Score is based on unique subjects, NOT resources
        // 2 subjects / 3 subjects = 0.667
        assertEquals(0.667, groupDef.getScore(), 0.001);
    }

    /**
     * Test that demonstrates non-boolean basis counts all subject resources.
     * <p>
     * With Encounter basis, PopulationDef.getCount() calls getAllSubjectResources().size().
     * Each resource is counted, even if multiple resources belong to the same subject.
     * <p>
     * This test uses the SAME population setup as testScoreGroup_BooleanBasis_CountsUniqueSubjects
     * but with "Encounter" basis instead of "boolean".
     * <p>
     * Expected:
     * - Numerator: 5 encounters (3 for patient1 + 2 for patient2)
     * - Denominator: 9 encounters (3 for patient1 + 2 for patient2 + 4 for patient3)
     * - Expected score: 5 encounters / 9 encounters = 0.556
     */
    @Test
    void testScoreGroup_EncounterBasis_CountsAllResources() {
        // Create numerator with 2 subjects, each having multiple resources
        ConceptDef numeratorCode = createMeasurePopulationConcept(MeasurePopulationType.NUMERATOR);
        PopulationDef numeratorPop =
                new PopulationDef("num-1", numeratorCode, MeasurePopulationType.NUMERATOR, "Numerator");

        // Patient1: 3 encounters in numerator
        numeratorPop.addResource("patient1", "Encounter/enc1");
        numeratorPop.addResource("patient1", "Encounter/enc2");
        numeratorPop.addResource("patient1", "Encounter/enc3");

        // Patient2: 2 encounters in numerator
        numeratorPop.addResource("patient2", "Encounter/enc4");
        numeratorPop.addResource("patient2", "Encounter/enc5");

        // Create denominator with 3 subjects, each having multiple resources
        ConceptDef denominatorCode = createMeasurePopulationConcept(MeasurePopulationType.DENOMINATOR);
        PopulationDef denominatorPop =
                new PopulationDef("den-1", denominatorCode, MeasurePopulationType.DENOMINATOR, "Denominator");

        // Patient1: 3 encounters in denominator
        denominatorPop.addResource("patient1", "Encounter/enc1");
        denominatorPop.addResource("patient1", "Encounter/enc2");
        denominatorPop.addResource("patient1", "Encounter/enc3");

        // Patient2: 2 encounters in denominator
        denominatorPop.addResource("patient2", "Encounter/enc4");
        denominatorPop.addResource("patient2", "Encounter/enc5");

        // Patient3: 4 encounters in denominator (NOT in numerator)
        denominatorPop.addResource("patient3", "Encounter/enc6");
        denominatorPop.addResource("patient3", "Encounter/enc7");
        denominatorPop.addResource("patient3", "Encounter/enc8");
        denominatorPop.addResource("patient3", "Encounter/enc9");

        // CRITICAL: Use Encounter basis (non-boolean)
        GroupDef groupDef = new GroupDef(
                "group-1",
                createTextOnlyConcept("Encounter Basis Test"),
                List.of(),
                List.of(numeratorPop, denominatorPop),
                MeasureScoring.PROPORTION,
                false,
                createImprovementNotationCode("increase"),
                createPopulationBasisCode("Encounter"));

        // Verify counts BEFORE scoring
        // Encounter basis: count ALL resources, not just unique subjects
        assertEquals(5, numeratorPop.getCount(groupDef)); // 5 encounters (3 + 2)
        assertEquals(9, denominatorPop.getCount(groupDef)); // 9 encounters (3 + 2 + 4)

        // Execute scoring
        MeasureDefScorer scorer = new MeasureDefScorer();
        scorer.scoreGroup("http://example.com/Measure/test", groupDef);

        // VERIFY: Score is based on encounter count, NOT subject count
        // 5 encounters / 9 encounters = 0.556
        assertEquals(0.556, groupDef.getScore(), 0.001);
    }

    // ============================================================================
    // Helper Methods for Test Data Construction
    // ============================================================================

    /**
     * Create PopulationDef with subjects for boolean basis populations.
     */
    private PopulationDef createPopulationDef(String id, MeasurePopulationType type, Set<String> subjects) {
        ConceptDef code = createMeasurePopulationConcept(type);
        PopulationDef pop = new PopulationDef(id, code, type, "expression");

        // Add subjects to population
        for (String subject : subjects) {
            pop.addResource(subject, true); // For boolean basis, resource is just boolean true
        }

        return pop;
    }

    /**
     * Create CodeDef for measure-population system.
     */
    private CodeDef createMeasurePopulationCode(String code) {
        return new CodeDef("http://terminology.hl7.org/CodeSystem/measure-population", code);
    }

    /**
     * Create CodeDef for measure-improvement-notation system.
     */
    private CodeDef createImprovementNotationCode(String notation) {
        return new CodeDef("http://terminology.hl7.org/CodeSystem/measure-improvement-notation", notation);
    }

    /**
     * Create CodeDef for measure population basis.
     */
    private CodeDef createPopulationBasisCode(String basis) {
        return new CodeDef("http://hl7.org/fhir/ValueSet/measure-population", basis);
    }

    /**
     * Create ConceptDef for measure population type.
     */
    private ConceptDef createMeasurePopulationConcept(MeasurePopulationType type) {
        return new ConceptDef(List.of(createMeasurePopulationCode(type.toCode())), type.toCode());
    }

    /**
     * Create ConceptDef with text only (no codes).
     */
    private ConceptDef createTextOnlyConcept(String text) {
        return new ConceptDef(List.of(), text);
    }
}
