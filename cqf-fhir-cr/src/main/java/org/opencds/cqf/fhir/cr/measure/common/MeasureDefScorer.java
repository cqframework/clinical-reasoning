package org.opencds.cqf.fhir.cr.measure.common;

import ca.uhn.fhir.rest.server.exceptions.InvalidRequestException;
import jakarta.annotation.Nullable;
import java.util.Collection;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import java.util.function.Function;
import java.util.stream.Collectors;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * Evaluation of Measure Report Data showing raw CQL criteria results compared to resulting Measure Report.
 *
 * <p>Each row represents a subject as raw cql criteria expression output:
 *
 * <pre>{@code
 * Subject | IP | D  | DX | N  | DE | NX | Notes
 * --------|----|----|----|----|----|----|---------------------------------------------------------------
 * A       | A  | A  | A  |    |    |    |
 * B       | B  | B  |    | B  |    |    |
 * C       | C  | C  |    |    | C  |    | InDenominator = true, InDenominatorException = true,
 *                                       | InNumerator = false
 * D       | D  | D  |    | D  |    | D  |
 * E       | E  | E  |    | E  |    |    |
 * F       |    |    |    | F  |    |    | Not in Initial Population or Denominator
 * G       | G  | G  |    | G  | G  |    | InDenominatorException = true & InNumerator = true
 * }</pre>
 *
 * <p>Each row represents a subject and their inclusion/exclusion population criteria on a Measure Report:
 *
 * <pre>{@code
 * Subject | IP | D  | DX | N  | DE | NX | Notes
 * --------|----|----|----|----|----|----|---------------------------------------------------------------
 * A       | A  | A  | A  |    |    |    |
 * B       | B  | B  |    | B  |    |    |
 * C       | C  | C  |    |    | C  |    | InDenominator = true, InDenominatorException = true,
 *                                       | InNumerator = false → Scores as InDenominatorException = true
 * D       | D  | D  |    | D  |    | D  |
 * E       | E  | E  |    | E  |    |    |
 * F       |    |    |    |    |    |    | Excluded: Not in Initial Population or Denominator
 * G       | G  | G  |    | G  |    |    | InDenominatorException = true & InNumerator = true → Remove from DE
 * }</pre>
 *
 * <p><strong>Population Counts:</strong>
 * <ul>
 *   <li>Initial Population (ip): 6</li>
 *   <li>Denominator (d): 6</li>
 *   <li>Denominator Exclusion (dx): 1</li>
 *   <li>Numerator (n): 4</li>
 *   <li>Denominator Exception (de): 1</li>
 *   <li>Numerator Exclusion (nx): 1</li>
 * </ul>
 *
 * <p><strong>Performance Rate Formula:</strong><br>
 * {@code (n - nx) / (d - dx - de)}<br>
 * {@code (4 - 1) / (6 - 1 - 1)} = <b>0.75</b>
 *
 * <p><strong>Measure Score:</strong> {@code 0.75}<br>
 *
 * <p>This is a FHIR-version-agnostic scorer that uses Def classes for iteration order
 * and mutates them by setting computed scores. Unlike R4/DSTU3MeasureReportScorer which
 * iterate over FHIR MeasureReport structures, this scorer iterates using:
 * <ul>
 *   <li>MeasureDef.groups() for group iteration</li>
 *   <li>GroupDef.stratifiers() for stratifier iteration</li>
 *   <li>StratifierDef.getStratum() for stratum iteration</li>
 *   <li>PopulationDef.getCount(GroupDef) for population counts</li>
 *   <li>StratumDef.getPopulationCount(PopulationDef) for stratum counts</li>
 * </ul>
 *
 * <p>This class computes scores and SETS them on Def objects using setScore() methods.
 * All methods are void. This makes Def classes the complete data model for measure scoring.
 *
 * <p>Generated by Claude Sonnet 4.5 on 2025-12-03
 */
public class MeasureDefScorer {

    private static final Logger logger = LoggerFactory.getLogger(MeasureDefScorer.class);

    /**
     * Score all groups in a measure definition - MUTATES GroupDef objects.
     *
     * @param measureUrl the measure URL for error reporting
     * @param measureDef the measure definition containing groups to score
     */
    public void score(String measureUrl, MeasureDef measureDef) {
        // Def-first iteration: iterate over MeasureDef.groups()
        for (GroupDef groupDef : measureDef.groups()) {
            scoreGroup(measureUrl, groupDef);
        }
    }

    /**
     * Score a single group including all its stratifiers - MUTATES GroupDef and StratumDef objects.
     *
     * @param measureUrl the measure URL for error reporting
     * @param groupDef the group definition to score (will be mutated with setScore())
     */
    public void scoreGroup(String measureUrl, GroupDef groupDef) {
        MeasureScoring measureScoring = checkMissingScoringType(measureUrl, groupDef.measureScoring());

        // Calculate group-level score
        Double groupScore = calculateGroupScore(measureUrl, groupDef, measureScoring);

        // MUTATE: Set score on GroupDef
        groupDef.setScore(groupScore);

        // Score all stratifiers using Def-first iteration
        // Modified from R4MeasureReportScorer to iterate over Def classes instead of FHIR components
        for (StratifierDef stratifierDef : groupDef.stratifiers()) {
            scoreStratifier(measureUrl, groupDef, stratifierDef, measureScoring);
        }
    }

    /**
     * Calculate score for a group based on its scoring type.
     */
    private Double calculateGroupScore(String measureUrl, GroupDef groupDef, MeasureScoring measureScoring) {
        switch (measureScoring) {
            case PROPORTION:
            case RATIO:
                // Special case: RATIO with separate numerator/denominator observations
                if (measureScoring == MeasureScoring.RATIO
                        && groupDef.hasPopulationType(MeasurePopulationType.MEASUREOBSERVATION)) {
                    return scoreRatioMeasureObservationGroup(measureUrl, groupDef);
                }

                // Standard proportion/ratio scoring: (n - nx) / (d - dx - de)
                int numerator = groupDef.getPopulationCount(MeasurePopulationType.NUMERATOR);
                int numeratorExclusion = groupDef.getPopulationCount(MeasurePopulationType.NUMERATOREXCLUSION);
                int denominator = groupDef.getPopulationCount(MeasurePopulationType.DENOMINATOR);
                int denominatorExclusion = groupDef.getPopulationCount(MeasurePopulationType.DENOMINATOREXCLUSION);
                int denominatorException = groupDef.getPopulationCount(MeasurePopulationType.DENOMINATOREXCEPTION);

                return calcProportionScore(
                        numerator - numeratorExclusion, denominator - denominatorExclusion - denominatorException);

            case CONTINUOUSVARIABLE:
                // Continuous variable scoring - returns aggregate value
                PopulationDef measureObsPop = groupDef.getSingle(MeasurePopulationType.MEASUREOBSERVATION);
                QuantityDef quantityDef = scoreContinuousVariable(measureUrl, measureObsPop);
                return quantityDef != null ? quantityDef.value() : null;

            default:
                return null;
        }
    }

    /**
     * Score a group for RATIO measures with MEASUREOBSERVATION populations.
     * Handles continuous variable ratio scoring where numerator and denominator have separate observations.
     *
     * @param measureUrl the measure URL for error reporting
     * @param groupDef the group definition
     * @return the calculated score or null
     */
    @Nullable
    private Double scoreRatioMeasureObservationGroup(String measureUrl, GroupDef groupDef) {
        // Get all MEASUREOBSERVATION populations
        var measureObservationPopulationDefs = groupDef.getPopulationDefs(MeasurePopulationType.MEASUREOBSERVATION);

        // Find Measure Observations for Numerator and Denominator
        PopulationDef numPopDef =
                findPopulationDef(groupDef, measureObservationPopulationDefs, MeasurePopulationType.NUMERATOR);
        PopulationDef denPopDef =
                findPopulationDef(groupDef, measureObservationPopulationDefs, MeasurePopulationType.DENOMINATOR);

        if (numPopDef == null || denPopDef == null) {
            return null;
        }

        // Calculate aggregate quantities for numerator and denominator
        QuantityDef numeratorAgg = calculateContinuousVariableAggregateQuantity(
                measureUrl, numPopDef, PopulationDef::getAllSubjectResources);
        QuantityDef denominatorAgg = calculateContinuousVariableAggregateQuantity(
                measureUrl, denPopDef, PopulationDef::getAllSubjectResources);

        if (numeratorAgg == null || denominatorAgg == null) {
            return null;
        }

        Double num = numeratorAgg.value();
        Double den = denominatorAgg.value();

        if (den == null || den == 0.0) {
            return null;
        }

        if (num == null || num == 0.0) {
            // Explicitly handle numerator zero with positive denominator
            return den > 0.0 ? 0.0 : null;
        }

        return num / den;
    }

    /**
     * Score continuous variable measure - returns QuantityDef with aggregated value.
     * Simplified version of R4MeasureReportScorer#scoreContinuousVariable that just
     * returns the aggregate without setting it on a FHIR report.
     */
    private QuantityDef scoreContinuousVariable(String measureUrl, PopulationDef populationDef) {
        return calculateContinuousVariableAggregateQuantity(
                measureUrl, populationDef, PopulationDef::getAllSubjectResources);
    }

    /**
     * Score all strata in a stratifier using Def-first iteration - MUTATES StratumDef objects.
     * Modified copy of R4MeasureReportScorer#scoreStratifier without FHIR components.
     *
     * @param measureUrl the measure URL for error reporting
     * @param groupDef the group definition containing the stratifier
     * @param stratifierDef the stratifier definition
     * @param measureScoring the scoring type
     */
    private void scoreStratifier(
            String measureUrl, GroupDef groupDef, StratifierDef stratifierDef, MeasureScoring measureScoring) {

        // Def-first iteration: iterate over StratifierDef.getStratum()
        for (StratumDef stratumDef : stratifierDef.getStratum()) {
            scoreStratum(measureUrl, groupDef, stratumDef, measureScoring);
        }
    }

    /**
     * Score a single stratum - MUTATES StratumDef object.
     * Modified copy of R4MeasureReportScorer#scoreStratum without StratifierGroupComponent.
     *
     * @param measureUrl the measure URL for error reporting
     * @param groupDef the group definition
     * @param stratumDef the stratum definition to score (will be mutated)
     * @param measureScoring the scoring type
     */
    private void scoreStratum(
            String measureUrl, GroupDef groupDef, StratumDef stratumDef, MeasureScoring measureScoring) {

        Double score = getStratumScoreOrNull(measureUrl, groupDef, stratumDef, measureScoring);

        // MUTATE: Set score on StratumDef
        stratumDef.setScore(score);
    }

    /**
     * Calculate stratum score based on scoring type.
     * Modified copy of R4MeasureReportScorer#getStratumScoreOrNull without StratifierGroupComponent.
     *
     * @param measureUrl the measure URL for error reporting
     * @param groupDef the group definition
     * @param stratumDef the stratum definition
     * @param measureScoring the scoring type
     * @return the calculated score or null
     */
    @Nullable
    private Double getStratumScoreOrNull(
            String measureUrl, GroupDef groupDef, StratumDef stratumDef, MeasureScoring measureScoring) {

        switch (measureScoring) {
            case PROPORTION:
            case RATIO:
                // Check for special RATIO continuous variable case
                if (measureScoring.equals(MeasureScoring.RATIO)
                        && groupDef.hasPopulationType(MeasurePopulationType.MEASUREOBSERVATION)) {
                    return scoreRatioMeasureObservationStratum(measureUrl, groupDef, stratumDef);
                } else {
                    return scoreProportionRatioStratum(groupDef, stratumDef);
                }

            case CONTINUOUSVARIABLE:
                return scoreContinuousVariableStratum(measureUrl, groupDef, stratumDef);

            default:
                return null;
        }
    }

    /**
     * Score a stratum for RATIO measures with MEASUREOBSERVATION populations.
     * Handles continuous variable ratio scoring where numerator and denominator have separate observations.
     * <p>
     * Optimized by Claude Sonnet 4.5 on 2025-12-05 to use pre-computed cache,
     * eliminating redundant lookups during scoring.
     *
     * @param measureUrl the measure URL for error reporting
     * @param groupDef the group definition
     * @param stratumDef the stratum definition
     * @return the calculated score or null
     */
    @Nullable
    private Double scoreRatioMeasureObservationStratum(String measureUrl, GroupDef groupDef, StratumDef stratumDef) {

        if (stratumDef == null) {
            return null;
        }

        // Use pre-computed cache - eliminates all lookups
        MeasureObservationStratumCache cache = stratumDef.getMeasureObservationCache();
        if (cache == null) {
            return null;
        }

        // Extract cached references
        StratumPopulationDef stratumPopulationDefNum = cache.numeratorObservation();
        StratumPopulationDef stratumPopulationDefDen = cache.denominatorObservation();

        // Get parent PopulationDefs directly from StratumPopulationDef
        PopulationDef numPopDef = stratumPopulationDefNum.populationDef();
        PopulationDef denPopDef = stratumPopulationDefDen.populationDef();

        return scoreRatioContVariableStratum(
                measureUrl, stratumPopulationDefNum, stratumPopulationDefDen, numPopDef, denPopDef);
    }

    /**
     * Score a stratum for standard PROPORTION or RATIO measures (non-continuous variable).
     * Uses simple numerator/denominator count ratio.
     *
     * @param groupDef the group definition
     * @param stratumDef the stratum definition
     * @return the calculated score or null
     */
    @Nullable
    private Double scoreProportionRatioStratum(GroupDef groupDef, StratumDef stratumDef) {
        int numeratorCount = stratumDef.getPopulationCount(groupDef.getSingle(MeasurePopulationType.NUMERATOR));
        int denominatorCount = stratumDef.getPopulationCount(groupDef.getSingle(MeasurePopulationType.DENOMINATOR));

        return calcProportionScore(numeratorCount, denominatorCount);
    }

    /**
     * Score a stratum for CONTINUOUSVARIABLE measures.
     * Aggregates MEASUREOBSERVATION population observations filtered by stratum subjects.
     *
     * @param measureUrl the measure URL for error reporting
     * @param groupDef the group definition
     * @param stratumDef the stratum definition
     * @return the calculated score or null
     */
    @Nullable
    private Double scoreContinuousVariableStratum(String measureUrl, GroupDef groupDef, StratumDef stratumDef) {

        // Get the MEASUREOBSERVATION population from GroupDef
        PopulationDef measureObsPop = groupDef.getSingle(MeasurePopulationType.MEASUREOBSERVATION);
        if (measureObsPop == null) {
            return null;
        }

        // Find the stratum population corresponding to MEASUREOBSERVATION
        StratumPopulationDef stratumPopulationDef = stratumDef.stratumPopulations().stream()
                .filter(stratumPopDef ->
                        stratumPopDef.id().startsWith(MeasurePopulationType.MEASUREOBSERVATION.toCode()))
                .findFirst()
                .orElse(null);

        if (stratumPopulationDef == null) {
            return null;
        }

        // Calculate aggregate using stratum-filtered resources
        QuantityDef quantityDef = calculateContinuousVariableAggregateQuantity(
                measureUrl, measureObsPop, populationDef -> getResultsForStratum(populationDef, stratumPopulationDef));

        return quantityDef != null ? quantityDef.value() : null;
    }

    /**
     * Score ratio continuous variable for a stratum.
     * Copied from R4MeasureReportScorer#scoreRatioContVariableStratum.
     *
     * @param measureUrl the measure URL for error reporting
     * @param measureObsNumStratum stratum population for numerator measure observation
     * @param measureObsDenStratum stratum population for denominator measure observation
     * @param numPopDef numerator population definition
     * @param denPopDef denominator population definition
     * @return the ratio score or null
     */
    private Double scoreRatioContVariableStratum(
            String measureUrl,
            StratumPopulationDef measureObsNumStratum,
            StratumPopulationDef measureObsDenStratum,
            PopulationDef numPopDef,
            PopulationDef denPopDef) {

        // Calculate aggregate for numerator observations filtered by stratum
        QuantityDef aggregateNumQuantityDef = calculateContinuousVariableAggregateQuantity(
                measureUrl, numPopDef, populationDef -> getResultsForStratum(populationDef, measureObsNumStratum));

        // Calculate aggregate for denominator observations filtered by stratum
        QuantityDef aggregateDenQuantityDef = calculateContinuousVariableAggregateQuantity(
                measureUrl, denPopDef, populationDef -> getResultsForStratum(populationDef, measureObsDenStratum));

        if (aggregateNumQuantityDef == null || aggregateDenQuantityDef == null) {
            return null;
        }

        Double num = aggregateNumQuantityDef.value();
        Double den = aggregateDenQuantityDef.value();

        if (den == null || den == 0.0) {
            return null;
        }

        if (num == null || num == 0.0) {
            // Explicitly handle numerator zero with positive denominator
            return den > 0.0 ? 0.0 : null;
        }

        return num / den;
    }

    /**
     * Find PopulationDef by matching criteria reference.
     * Copied from BaseMeasureReportScorer - version-agnostic helper.
     *
     * @param groupDef the group definition
     * @param populationDefs list of MEASUREOBSERVATION populations to search
     * @param type the population type to find
     * @return matching PopulationDef or null
     */
    @Nullable
    private PopulationDef findPopulationDef(
            GroupDef groupDef, List<PopulationDef> populationDefs, MeasurePopulationType type) {
        PopulationDef firstPop = groupDef.getFirstWithId(type);
        if (firstPop == null) {
            return null;
        }

        String criteriaId = firstPop.id();

        return populationDefs.stream()
                .filter(p -> criteriaId.equals(p.getCriteriaReference()))
                .findFirst()
                .orElse(null);
    }

    /**
     * Extract StratumPopulationDef from StratumDef that matches a PopulationDef.
     * Uses direct PopulationDef reference instead of ID matching.
     *
     * @param stratumDef the stratum definition
     * @param populationDef the population definition to match
     * @return matching StratumPopulationDef or null
     */
    @Nullable
    private StratumPopulationDef getStratumPopDefFromPopDef(StratumDef stratumDef, PopulationDef populationDef) {
        if (populationDef == null) {
            return null;
        }
        return stratumDef.stratumPopulations().stream()
                .filter(t -> t.populationDef() == populationDef)
                .findFirst()
                .orElse(null);
    }

    /**
     * Get results filtered for a specific stratum.
     * Filters at the subject level (Map.Entry key) rather than observation Map keys.
     * Aligned with BaseMeasureReportScorer pattern for correct stratification.
     *
     * @param populationDef the population definition (MEASUREOBSERVATION)
     * @param stratumPopulationDef the stratum population to filter by
     * @return collection of resources belonging to this stratum
     */
    private static Collection<Object> getResultsForStratum(
            PopulationDef populationDef, StratumPopulationDef stratumPopulationDef) {

        if (stratumPopulationDef == null) {
            return List.of();
        }

        // Filter to only resources that belong to subjects in this stratum
        Set<String> stratumSubjects = stratumPopulationDef.subjectsQualifiedOrUnqualified();

        // Filter at the subjectResources Map.Entry level (subject ID is the key)
        return populationDef.getSubjectResources().entrySet().stream()
                .filter(entry -> stratumSubjects.contains(entry.getKey()))
                .map(Map.Entry::getValue)
                .flatMap(Collection::stream)
                .collect(Collectors.toList());
    }

    /**
     * Calculate continuous variable aggregate quantity.
     * Copied from R4MeasureReportScorer with minor adaptations.
     *
     * @param measureUrl the measure URL for error reporting
     * @param populationDef the population definition containing observation data
     * @param popDefToResources function to extract resources from population def
     * @return aggregated QuantityDef or null if population is null
     */
    @Nullable
    private static QuantityDef calculateContinuousVariableAggregateQuantity(
            String measureUrl,
            PopulationDef populationDef,
            Function<PopulationDef, Collection<Object>> popDefToResources) {

        if (populationDef == null) {
            logger.warn("Measure population group has no measure population defined for measure: {}", measureUrl);
            return null;
        }

        return calculateContinuousVariableAggregateQuantity(
                populationDef.getAggregateMethod(), popDefToResources.apply(populationDef));
    }

    /**
     * Calculate continuous variable aggregate quantity.
     * Copied from R4MeasureReportScorer.
     *
     * @param aggregateMethod the aggregation method (SUM, AVG, MIN, MAX, MEDIAN, COUNT)
     * @param qualifyingResources the resources containing QuantityDef observations
     * @return aggregated QuantityDef or null if no resources
     */
    @Nullable
    private static QuantityDef calculateContinuousVariableAggregateQuantity(
            ContinuousVariableObservationAggregateMethod aggregateMethod, Collection<Object> qualifyingResources) {
        var observationQuantity = collectQuantities(qualifyingResources);
        return aggregate(observationQuantity, aggregateMethod);
    }

    /**
     * Aggregate a list of QuantityDefs using the specified method.
     * Copied from R4MeasureReportScorer.
     *
     * @param quantities list of QuantityDef to aggregate
     * @param method aggregation method
     * @return aggregated QuantityDef with computed value
     */
    private static QuantityDef aggregate(
            List<QuantityDef> quantities, ContinuousVariableObservationAggregateMethod method) {
        if (quantities == null || quantities.isEmpty()) {
            return null;
        }

        if (ContinuousVariableObservationAggregateMethod.N_A == method) {
            throw new InvalidRequestException(
                    "Aggregate method must be provided for continuous variable scoring, but is NO-OP.");
        }

        // Enhanced switch with early returns - short-circuit logic
        return switch (method) {
            case COUNT -> new QuantityDef((double) quantities.size());
            case MEDIAN -> {
                List<Double> sorted = quantities.stream()
                        .map(QuantityDef::value)
                        .filter(Objects::nonNull)
                        .sorted()
                        .toList();
                int n = sorted.size();
                double result = (n % 2 == 1) ? sorted.get(n / 2) : (sorted.get(n / 2 - 1) + sorted.get(n / 2)) / 2.0;
                yield new QuantityDef(result);
            }
            case SUM -> {
                double result = quantities.stream()
                        .map(QuantityDef::value)
                        .filter(Objects::nonNull)
                        .mapToDouble(value -> value)
                        .sum();
                yield new QuantityDef(result);
            }
            case MAX -> {
                double result = quantities.stream()
                        .map(QuantityDef::value)
                        .filter(Objects::nonNull)
                        .mapToDouble(value -> value)
                        .max()
                        .orElse(Double.NaN);
                yield new QuantityDef(result);
            }
            case MIN -> {
                double result = quantities.stream()
                        .map(QuantityDef::value)
                        .filter(Objects::nonNull)
                        .mapToDouble(value -> value)
                        .min()
                        .orElse(Double.NaN);
                yield new QuantityDef(result);
            }
            case AVG -> {
                double result = quantities.stream()
                        .map(QuantityDef::value)
                        .filter(Objects::nonNull)
                        .mapToDouble(value -> value)
                        .average()
                        .orElse(Double.NaN);
                yield new QuantityDef(result);
            }
            default -> throw new IllegalArgumentException("Unsupported aggregation method: " + method);
        };
    }

    /**
     * Collect QuantityDef objects from nested Map structures in resources.
     * Copied from R4MeasureReportScorer.
     *
     * @param resources collection of objects that may contain Maps with QuantityDef values
     * @return list of QuantityDef objects found
     */
    private static List<QuantityDef> collectQuantities(Collection<Object> resources) {
        var mapValues = resources.stream()
                .filter(x -> x instanceof Map<?, ?>)
                .map(x -> (Map<?, ?>) x)
                .map(Map::values)
                .flatMap(Collection::stream)
                .toList();

        return mapValues.stream()
                .filter(QuantityDef.class::isInstance)
                .map(QuantityDef.class::cast)
                .toList();
    }

    /**
     * Calculate proportion/ratio score: numerator / denominator.
     * Reused from BaseMeasureReportScorer pattern.
     */
    protected Double calcProportionScore(Integer numeratorCount, Integer denominatorCount) {
        if (numeratorCount == null) {
            numeratorCount = 0;
        }
        if (denominatorCount != null && denominatorCount != 0) {
            return numeratorCount / (double) denominatorCount;
        }
        return null;
    }

    /**
     * Validate scoring type is present.
     * Reused from BaseMeasureReportScorer pattern.
     */
    protected MeasureScoring checkMissingScoringType(String measureUrl, MeasureScoring measureScoring) {
        if (measureScoring == null) {
            throw new InvalidRequestException(
                    "Measure does not have a scoring methodology defined. Add a \"scoring\" property to the measure definition or the group definition for measure: "
                            + measureUrl);
        }
        return measureScoring;
    }
}
