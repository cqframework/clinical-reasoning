import cqf.LinkedBuildRegistry

// Convention plugin for CI tasks: resolving linked builds from PR descriptions,
// and other CI automation that can be run both locally and in GitHub Actions.

tasks.register("resolveLinkedBuilds") {
    group = "ci"
    description = "Parses Depends-On from the PR description and sets up composite builds for linked repos."

    outputs.upToDateWhen { false }

    doLast {
        fun run(vararg args: String): String {
            val proc = ProcessBuilder(*args)
                .directory(project.projectDir)
                .redirectErrorStream(true)
                .start()
            val output = proc.inputStream.bufferedReader().readText()
            val exitCode = proc.waitFor()
            if (exitCode != 0) {
                throw GradleException("Command failed (exit $exitCode): ${args.toList()}\n$output")
            }
            return output.trim()
        }

        val prNumber = (findProperty("prNumber") as? String)
            ?: System.getenv("PR_NUMBER")
            ?: throw GradleException(
                "resolveLinkedBuilds requires a PR number. " +
                    "Pass -PprNumber=123 or set PR_NUMBER env var."
            )

        // Fetch PR body via gh CLI
        val prBody = run("gh", "pr", "view", prNumber, "--json", "body", "--jq", ".body")

        // Parse "Depends-On: org/repo#branch" lines
        val pattern = Regex("""Depends-On:\s*([^\s#]+)#(\S+)""", RegexOption.IGNORE_CASE)
        val matches = pattern.findAll(prBody).toList()

        val localPropsFile = file("local.properties")

        if (matches.isEmpty()) {
            logger.lifecycle("No Depends-On directives found in PR #$prNumber")
            if (localPropsFile.exists()) localPropsFile.delete()
            return@doLast
        }

        val properties = java.util.Properties()
        val linkedBuildsDir = file("build/linked-builds")

        for (match in matches) {
            val repoSlug = match.groupValues[1]
            val branch = match.groupValues[2]
            val repoName = repoSlug.substringAfter("/")

            val build = LinkedBuildRegistry.forSlug(repoSlug)
            if (build == null) {
                logger.warn("Unknown repo in Depends-On: $repoSlug (not in LinkedBuildRegistry)")
                continue
            }

            logger.lifecycle("Linked build: $repoSlug @ $branch")

            val cloneDir = linkedBuildsDir.resolve(repoName)
            if (cloneDir.exists()) {
                cloneDir.deleteRecursively()
            }
            cloneDir.parentFile.mkdirs()

            run(
                "git", "clone", "--depth", "1", "--branch", branch,
                "https://github.com/$repoSlug.git",
                cloneDir.absolutePath
            )

            val buildPath = if (build.buildRoot.isNotEmpty()) {
                "${cloneDir.absolutePath}/${build.buildRoot}"
            } else {
                cloneDir.absolutePath
            }

            properties.setProperty(build.propertyKey, buildPath)
        }

        if (properties.isEmpty) {
            logger.lifecycle("No matching linked builds resolved")
            if (localPropsFile.exists()) localPropsFile.delete()
        } else {
            localPropsFile.writer().use { w ->
                properties.store(w, "Auto-generated by resolveLinkedBuilds â€” do not edit")
            }
            logger.lifecycle("Wrote ${localPropsFile.name} with ${properties.size} linked build(s)")
        }
    }
}
